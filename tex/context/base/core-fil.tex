%D \module
%D   [       file=core-fil,
%D        version=1997.11.15,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=File Support,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for 
%C details. 

\writestatus{loading}{Context Core Macros / File Support}

\unprotect

% NOT YET DOCUMENTED !!
%
% overal \normalinput 
 
\startmessages  dutch  library: files
   title: files 
       1: file synoniem -- is al in gebruik voor --
\stopmessages

\startmessages  english  library: files
   title: files 
       1: file synonym -- is already used for --
\stopmessages

\startmessages  german  library: files
   title: files
       1: Dateisynonym -- wird bereits fuer -- benutzt
\stopmessages

\startmessages  czech  library: files
   title: soubory
       1: synonymum souboru -- je jiz pouzito pro --
\stopmessages

%D \macros 
%D   {definefilesynonym}
%D
%D One of the problems with loading files is that their names 
%D can depend on the interface language. We therefore need a 
%D method to define filesynonyms. The actual synonyms are 
%D defined elsewhere, but look like:
%D 
%D \starttypen
%D \definefilesynonym [chemic]  [chemie]
%D \definefilesynonym [einheit] [eenheid]
%D \definefilesynonym [unit]    [eenheid]
%D \stoptypen
%D 
%D So we can say in english:
%D 
%D \starttypen
%D \usemodules[pictex,chemic,unit]
%D \stoptypen
%D 
%D and in dutch:
%D 
%D \starttypen
%D \usemodules[pictex,chemie,eenheid]
%D \stoptypen

\def\definefilesynonym%
  {\dodoubleempty\dodefinefilesynonym}

\def\dodefinefilesynonym[#1][#2]%
  {\doifdefined{\??fs#1}
     {\doifnotvalue{\??fs#1}{#2} 
        {\showmessage{\m!files}{1}{#1 (#2),\getvalue{\??fs#1}}}}%
   \doifelse{#1}{#2}
     {\letbeundefined{\??fs#1}{#2}}
     {\setevalue{\??fs#1}{#2}}}
    
%D \macros 
%D   {truefilename}
%D
%D At the system level such a filename can be called upon by 
%D saying:
%D 
%D \starttypen
%D \truefilename{filename/filesynonym}
%D \stoptypen
%D 
%D The implementation shows that nesting is supported. 

\def\truefilename#1%
  {\ifundefined{\??fs#1}%
     #1%
   \else
     \truefilename{\getvalue{\??fs#1}}%
   \fi}

%D \macros
%D   {makeshortfilename}
%D
%D To prevent cross platform problems with filenames, we
%D lowercase them as well as only use the first 8~characters. 

\def\domakeshortfilename[#1#2#3#4#5#6#7#8#9]%
  {\lowercase{\edef\shortfilename{#1#2#3#4#5#6#7#8.}}%
   \expandafter\beforesplitstring\shortfilename\at.\to\shortfilename}

\def\makeshortfilename[#1]%
  {\edef\fullfilename{#1.........}%
   \expanded{\domakeshortfilename[\fullfilename]}}

%D \macros
%D   {usemodule}
%D 
%D Most of \CONTEXT is preloaded in the format file. Some very
%D domain specific typesetting topics are however dealt with in
%D separate modules, e.g. typesetting of chemical structure
%D formulas. These modules are loaded by: 
%D 
%D \showsetup{\y!usemodule}
%D 
%D More information on the specific modules can be found in
%D their dedicated manuals. 

\newconditional\moduleisloaded

\def\dododousemodules#1#2%
  {\ifconditional\moduleisloaded\else
     \makeshortfilename[#1\truefilename{#2}]%
     \doifundefinedelse{\shortfilename\v!aan}
       {\setgvalue{\shortfilename\v!aan}{}%
        \startreadingfile
        \readsysfile{\shortfilename}%
          {\showmessage{\m!systems}{5}{#2}%
           \settrue\moduleisloaded}%
          {}%
        \stopreadingfile}
       {\showmessage{\m!systems}{7}{#2}%
        \settrue\moduleisloaded}%
   \fi}

\def\dodousemodules#1%
  {\setfalse\moduleisloaded
   \dododousemodules\f!moduleprefix {#1}%
   \dododousemodules\f!styleprefix  {#1}%
   \dododousemodules\f!privateprefix{#1}%
   \ifconditional\moduleisloaded\else
     \showmessage{\m!systems}{6}{#1}%
   \fi}

\def\dousemodules[#1]%
  {\doifsomething{#1}{\processcommalist[#1]\dodousemodules}%
   }% \enablelanguagespecifics[\currentmainlanguage]}

\def\usemodules%
  {\dosingleargument\dousemodules}

%D We also support a singular call, which saves us for 
%D frustrations when we do a typo.

\let\usemodule=\usemodules

% %D The definition shows that the language specific settings 
% %D are activated after loading all the modules specified. 

%D \macros
%D   {ifprotectbuffers, bufferprefix,
%D    TEXbufferfile, MPgraphicfile}
%D
%D The next switch enables protection of temporary filenames, 
%D which is needed when we process more files on one path at
%D the same time.  

\newif\ifprotectbuffers

\def\bufferprefix%
  {\ifprotectbuffers\jobname-\fi}

% also 

\def\TEXbufferfile#1%
  {\bufferprefix#1.\f!temporaryextension}

%D We also redefine: 

\def\MPgraphicfile%
   {\bufferprefix mp\ifMPrun run\else graph\fi}

\def\convertMPcolorfile%
   {\bufferprefix metacmyk.tmp}

%D Temporarily here: 

\def\definieerfilegroep%
  {\dodoubleargument\dodefinieerfilegroep}

\def\dodefinieerfilegroep[#1][#2]%
  {\getparameters
     [\??fp#1]
     [\c!file=#1,
      \c!voor=,
      \c!na=,
      #2]%
   \setvalue{\e!start#1}{\dostartfilegroep[#1]}}

\def\dostartfilegroep%
  {\dodoubleargument\dodostartfilegroep}

\def\dodostartfilegroep[#1][#2]%
  {\getvalue{\??fp#1\c!voor}%
   \setvalue{\e!stop#1}{\dostopfilegroep[#1][#2]}%
   \edef\!!stringa{\getvalue{\??fp#1\c!file}-#2}%
   \@EA\dolaadfilegroep\@EA[\!!stringa]%
   \getvalue{\e!start#1#2}}

\def\dolaadfilegroep[#1-#2#3#4#5]%
  {\readsysfile{#1-#2#3#4}{}{}}

\def\dostopfilegroep[#1][#2]%
  {\getvalue{\e!stop#1#2}%
   \getvalue{\??fp#1\c!na}}

%D This will be perfected / changed / weeded. 
 
\protect

\endinput
