% NOT YET DOCUMENTED !!
%
% overal \normalinput 
 
%D \module
%D   [       file=core-fil,
%D        version=1997.11.15,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=File Support,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. Non||commercial use is
%C granted.

\writestatus{loading}{Context Core Macros / File Support}

\unprotect

\startmessages  dutch  library: files
   title: files 
       1: file synoniem -- is al in gebruik voor --
\stopmessages

\startmessages  english  library: files
   title: files 
       1: file synonym -- is already used for --
\stopmessages

\startmessages  german  library: files
   title: files
       1: Dateisynonym -- wird bereits fuer -- benutzt
\stopmessages

%D \macros 
%D   {definefilesynonym}
%D
%D One of the problems with loading files is that their names 
%D can depend on the interface language. We therefore need a 
%D method to define filesynonyms. The actual synonyms are 
%D defined elsewhere, but look like:
%D 
%D \starttypen
%D \definefilesynonym [chemic]  [chemie]
%D \definefilesynonym [einheit] [eenheid]
%D \definefilesynonym [unit]    [eenheid]
%D \stoptypen
%D 
%D So we can say in english:
%D 
%D \starttypen
%D \usemodules[pictex,chemic,unit]
%D \stoptypen
%D 
%D and in dutch:
%D 
%D \starttypen
%D \usemodules[pictex,chemie,eenheid]
%D \stoptypen

\def\definefilesynonym%
  {\dodoubleempty\dodefinefilesynonym}

\def\dodefinefilesynonym[#1][#2]%
  {\doifdefinedelse{\??fs#1}
     {\showmessage{\m!systems}{1}{#1 (#2),\getvalue{\??fs#1}}} % alleen naar log 
     {\setevalue{\??fs#1}{#2}}}
    
%D \macros 
%D   {truefilename}
%D
%D At the system level such a filename can be called upon by 
%D saying:
%D 
%D \starttypen
%D \truefilename{filename/filesynonym}
%D \stoptypen
%D 
%D The implementation shows that nesting is supported. 

\def\truefilename#1%
  {\ifundefined{\??fs#1}%
     #1%
   \else
     \truefilename{\getvalue{\??fs#1}}%
   \fi}

%D \macros
%D   {makeshortfilename}
%D
%D To prevent cross platform problems with filenames, we
%D lowercase them as well as only use the first 8~characters. 

\def\domakeshortfilename[#1#2#3#4#5#6#7#8#9]%
  {\lowercase{\edef\shortfilename{#1#2#3#4#5#6#7#8.}}%
   \expandafter\beforesplitstring\shortfilename\at.\to\shortfilename}

\def\makeshortfilename[#1]%
  {\edef\fullfilename{#1.........}%
   \expanded{\domakeshortfilename[\fullfilename]}}

%D \macros
%D   {usemodule}
%D 
%D Most of \CONTEXT is preloaded in the format file. Some very
%D domain specific typesetting topics are however dealt with in
%D separate modules, e.g. typesettingof chemical structure
%D formulas. These modules are loaded by: 
%D 
%D \showsetup{\y!usemodule}
%D 
%D More information on the specific modules can be found in
%D their dedicated manuals. 

\def\dododousemodules#1#2%
  {\makeshortfilename[#1\truefilename{#2}]%
   \doifundefinedelse{\shortfilename\v!aan}
     {\setgvalue{\shortfilename\v!aan}{}%
      \startreadingfile
      \readsysfile{\shortfilename}%
        {\showmessage{\m!systems}{5}{#1#2}}%
        {\showmessage{\m!systems}{6}{#1#2}}%
      \stopreadingfile}
     {\showmessage{\m!systems}{7}{#2}}}

\def\dodousemodules#1%
  {\dododousemodules\f!moduleprefix {#1}%
   \dododousemodules\f!styleprefix  {#1}%
   \dododousemodules\f!privateprefix{#1}}

\def\dousemodules[#1]%
  {\doifsomething{#1}{\processcommalist[#1]\dodousemodules}%
   }% \enablelanguagespecifics[\currentmainlanguage]}

\def\usemodules%
  {\dosingleargument\dousemodules}

%D We also support a singular call, which saves us for 
%D frustrations when we do a typo.

\let\usemodule=\usemodules

% %D The definition shows that the language specific settings 
% %D are activated after loading all the modules specified. 

\protect

\endinput
