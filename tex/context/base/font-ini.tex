%D \module
%D   [       file=font-ini,
%D        version=1998.09.11,
%D          title=\CONTEXT\ Font Macros,
%D       subtitle=Initialization,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for 
%C details. 

\writestatus{loading}{Context Font Macros (ini)}

\unprotect

\startmessages  dutch  library: fonts
  title: korps
      1: codering --
      2: variant -- wordt geladen
      3: onbekende variant --
      4: korps -- is niet gedefinieerd
      5: stijl -- is niet gedefinieerd
      6: -- wordt geladen
      7: onbekend formaat --
      8: stijl -- gedefinieerd
      9: mapping -- is geladen
     10: onbekende font file --
\stopmessages

\startmessages  english  library: fonts
  title: bodyfont
      1: coding --
      2: variant -- is loaded
      3: unknown variant --
      4: bodyfont -- is not defined
      5: style -- is not defined
      6: -- is loaded
      7: unknown format --
      8: style -- defined
      9: mapping -- is loaded
     10: unknown font file --
\stopmessages

\startmessages  german  library: fonts
  title: Fliesstext
      1: Kodierung --
      2: Variante -- ist geladen
      3: Unbekannte Variante --
      4: Fliesstext -- ist nicht definiert
      5: Stil -- ist nicht definiert
      6: -- ist geladen
      7: unbekanntes Format --
      8: Stil -- definiert
      9: Map -- ist geladen
     10: unbekanntes Font --
\stopmessages

\startmessages  czech  library: fonts
  title: zakladnifont
      1: kodovani --
      2: varianta -- je nactena
      3: neznama varianta --
      4: zakladni font -- neni definovan
      5: styl -- neni definovan
      6: -- je nacten
      7: neznamy format --
      8: styl -- definovan
      9: mapovani -- je nacteno
     10: neznamy font --
\stopmessages

%D This module is one of the oldest modules of \CONTEXT. The
%D macros below evolved out of the \PLAIN\ \TEX\ macros and
%D therefore use a similar naming scheme (\type{\rm},
%D \type{\bf}, etc). This module grew out of our needs. We
%D started with the \PLAIN\ \TEX\ definitions, generalized the
%D underlaying macros, and extended those to a level at which
%D probably no one will ever recognize them.
%D
%D One important characteristic of the font mechanism presented
%D here is the postponing of font loading. This makes it
%D possible to distribute \type{fmt} files without bothering
%D about the specific breed of \type{tfm} files.
%D
%D Another feature implemented here is the massive switching
%D from roman to {\ss sans serif}, {\tt teletype} or else. This
%D means one doesn't have to take care of all kind of relations
%D between fonts.
%D
%D \pagina[grotevoorkeur]

%D \macros
%D   {rm,ss,tt,hw,cg}
%D
%D Fonts are defined in separate files. When we define a font,
%D we distinguish between several styles. In most cases we will
%D use:
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC roman regular serif    \NC \type{\rm} \NC\FR
%D \NC sansserif sans support \NC \type{\ss} \NC\MR
%D \NC type teletype mono     \NC \type{\tt} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D The number of styles is not limited to these three. When
%D using Lucida Bright we can for instance also define:
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC handwritten  \NC \type{\hw} \NC\FR
%D \NC calligraphic \NC \type{\cg} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D Anyone who feels the need, can define additional ones, like
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC faxfont    \NC \type{\ff} \NC\FR
%D \NC blackboard \NC \type{\bb} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D Or even
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC hebrew \NC \type{\hb} \NC\SR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D Styles are grouped in font sets. At the moment there are
%D three main sets defined:
%D
%D \startregelcorrectie
%D \starttabel[|l|l||]
%D \HL
%D \NC Computer Modern Roman     \NC Knuth             \NC \type{cmr} \NC\FR
%D \NC Lucida Bright             \NC Bigelow \& Holmes \NC \type{lbr} \NC\MR
%D \NC Standard Postscript Fonts \NC Adobe             \NC \type{pos} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D There are also some Computer Modern Roman alternatives:
%D
%D \startregelcorrectie
%D \starttabel[|l|l||]
%D \HL
%D \NC Computer Modern Roman    \NC Knuth \& Sauter \NC \type{sau} \NC\FR
%D \NC Euler fonts              \NC Zapf            \NC \type{eul} \NC\MR
%D \NC Computer Modern Concrete \NC Knuth \& Zapf   \NC \type{con} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D All these definitions are ordered in files with names like
%D \type{font-cmr} and \type{font-pos}, where the last three
%D characters specify the name as known to \CONTEXT.
%D
%D Within such a font set (\type{cmr}) and style (\type{\rm})
%D we can define a number of text font alternatives:
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC typeface    \NC \type{\tf} \NC\FR
%D \NC boldface    \NC \type{\bf} \NC\MR
%D \NC slanted     \NC \type{\sl} \NC\MR
%D \NC italic      \NC \type{\it} \NC\MR
%D \NC boldslanted \NC \type{\bs} \NC\MR
%D \NC bolditalic  \NC \type{\bi} \NC\MR
%D \NC smallcaps   \NC \type{\sc} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie

%D The more primitive is (still) predefined:
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC oldstyle \NC \type{\os} \NC\SR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D The availability of these alternatives depends on the
%D completeness of a font family and of course the definitions
%D in the font files.
%D
%D But let's not forget math. In addition to the previous \TEX\
%D families (the mysterious \type{\fam}'s) we've got some more:
%D
%D \startregelcorrectie
%D \starttabel[|l||]
%D \HL
%D \NC Math Roman  \NC \type{\mr} \NC\FR
%D \NC Math Italic \NC \type{\mi} \NC\MR
%D \NC Math Symbol \NC \type{\sy} \NC\MR
%D \NC Math Extra  \NC \type{\ex} \NC\MR
%D \NC Math A      \NC \type{\ma} \NC\MR
%D \NC Math B      \NC \type{\mb} \NC\MR
%D \NC Math C      \NC \type{\mc} \NC\LR
%D \HL
%D \stoptabel
%D \stopregelcorrectie
%D
%D Users can call for specific fonts in many ways. Switches to
%D other typefaces, like the switch from normal to bold, are as
%D intuitive as possible, which means that all dependant fonts
%D also switch. One can imagine that this takes quite some
%D processing time.
%D
%D Internally fonts are stored as combination of size, style
%D and alternative, e.g. \type{12pt}+\type{\ss}+\type{\bf}.
%D Users are not confronted with sizes, but use the style or
%D style+alternative to activate them.
%D
%D During the definition of a bodyfont one can also declare the
%D available larger alternatives:
%D
%D \starttypen
%D \tf \tfa \tfb \tfc ...
%D \bf \bfa \bfb \bfc ...
%D \sl \sla \slb \slc ...
%D \stoptypen
%D
%D The smaller ones are automatically supplied and derived from
%D the the bodyfont environment.
%D
%D \starttypen
%D \tfx \tfxx
%D \bfx \bfxx
%D \slx \slxx
%D \stoptypen
%D
%D There are only two smaller alternatives per style. The
%D larger alternatives on the other hand have no limitations.
%D
%D These larger alternatives are mostly used in chapter and
%D section titles or on title pages. When one switches to a
%D larger alternative, the bold an other ones automatically
%D adapt themselves:
%D
%D \startbuffer
%D \tfd Hi \bf there\sl, here \tfb I \bf am
%D \stopbuffer
%D
%S \startsmaller
%D \typebuffer
%S \stopsmaller
%D
%D therefore becomes:
%D
%D \startvoorbeeld
%D \haalbuffer
%D \stopvoorbeeld
%D
%D Maybe this mechanism isn't always as logic, but as said
%D before, we tried to make it as intuitive as possible.
%D
%D So a specific kind of glyph can be characterized by:
%D
%D \startsmaller
%D family (cmr) + bodyfont (12pt) + style (rm) + alternative (bf) + size (a)
%D \stopsmaller
%D
%D The last component (the size) is optional.
%D
%D We introduced \type{\tf} as command to call for the current
%D normally sized typeface. This commands results in roman,
%D sans serif, teletype or whatever style is in charge. Such
%D rather massive switches of style sometimes take more
%D processing time than comfortable. Of course there is a
%D workaround for this: we can call fonts directly by means of
%D commands like:
%D
%D \starttypen
%D \rmtf \sssl \tttf \rmbsa
%D \stoptypen
%D
%D One should realize that this fast calls have limitations,
%D they lack for instance automatic super- and subscript
%D support.
%D
%D This leaves us two more commands: \type{\tx} and
%D \type{\txx}. These activate a smaller and even more smaller
%D font than the current one and adapt themselves to the
%D current alternative, so when \type{\bf} is active,
%D \type{\tx} gives a smaller boldface, which in turn can be
%D called directly by \type{\bfx}.
%D
%D These two smaller alternatives are specified by the bodyfont
%D environment and therefore not necessarily have similar sizes
%D as \type{\scriptsize} and \type{\scriptscriptsize}. The main
%D reason for this incompatibility (which can easily be undone)
%D lays in the fact that we often want a bit bigger characters
%D than in math mode. In \CONTEXT\ for instance the \type{\tx}
%D and \type{\txx} commands are used for surrogate
%D \kap{smallcaps} which support both nesting and alternatives,
%D like in {\bf\kap{a \kap{small} world}}, which was typeset by
%D
%D \starttypen
%D \bf\kap{a \kap{small} world}
%D \stoptypen
%D
%D And compare $\rm \scriptstyle THIS$ with the slightly larger
%D \kap{THIS}: \ruledhbox{$\rm \scriptstyle\ scriptstyle THIS$}
%D or \ruledhbox{\kap{THIS x style}} makes a big difference.

%D \macros
%D   {mf}
%D
%D Math fonts are a species in their own. They are tightly
%D hooked into smaller and even smaller ones of similar breed
%D to form a tight family. Let's first see how these are
%D related:
%D
%D \startbuffer
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+ \bi x^2 =\rm 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+{\bi x^2}=\rm 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+ \bi x^2 =\tf 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+{\bi x^2}=\tf 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+ \bi x^2 =\bf 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+{\bi x^2}=\bf 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+ \bi x^2 =\sl 6x^2$
%D $\tf x^2+\bf x^2+\sl x^2+\it x^2+\bs x^2+{\bi x^2}=\sl 6x^2$
%D \stopbuffer
%D
%D \typebuffer
%D
%D Gives both an expected and unexpected result:
%D
%D \startvoorbeeld
%D \startregels
%D \haalbuffer
%D \stopregels
%D \stopvoorbeeld
%D
%D We see here that the character shapes change accordingly to
%D the current family, but that the symbols are always typeset
%D in the font assigned to \type{\fam0}.
%D
%D \startbuffer
%D $\tf\mf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = 6x^2$
%D $\bf\mf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = 6x^2$
%D $\sl\mf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = 6x^2$
%D $\bs\mf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = 6x^2$
%D $\it\mf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = 6x^2$
%D $\bi\mf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = 6x^2$
%D \stopbuffer
%D
%D \startvoorbeeld
%D \startregels
%D \haalbuffer
%D \stopregels
%D \stopvoorbeeld
%D
%D In this example we see a new command \type{\mf} surface
%D which means as much as {\em math font}. This commands
%D reactivates the last font alternative and therefore equals
%D \type{\bf}, \type{\sl} etc. but by default it equals
%D \type{\tf}:

\unexpanded\def\mf%
  {\dodosetmathfont{\fontalternative}%
   \getvalue{\fontalternative}}

%D The previous example was typeset saying:
%D
%D \typebuffer
%D
%D Beware: the exact location of \type{\mf} is not that
%D important, we could as well has said
%D
%D \startbuffer
%D $\bf x^2 + x^2 + x^2 + x^2 + x^2 + x^2 = \mf 6x^2$
%D \stopbuffer
%D
%D \typebuffer
%D
%D This is due to the way \TEX\ handles fonts in math mode.
%D
%D Of course we'll have to redefine \type{\mf} every time we
%D change the current \type{\fam}.

%D \macros
%D   {mbox,enablembox,mathop}
%D
%D Now how can we put this to use? Will the next sequence
%D give the desired result?
%D
%D \startbuffer
%D $\bf x^2 + \hbox{\mf whatever} + \sin(2x)$
%D \stopbuffer
%D
%D \typebuffer
%D
%D It won't!
%D
%D \startvoorbeeld
%D \let\mathop=\normalmathop \haalbuffer
%D \stopvoorbeeld
%D
%D The reason for this is that \type{\sin} is defined as:
%D
%D \starttypen
%D \def\sin{\mathop{\rm sin}\nolimits}
%D \stoptypen
%D
%D We can fix this by defining

\let\normalmathop=\mathop

\def\mathop%
  {\normalmathop
   \bgroup
   \let\rm=\mf
   \let\next=}

%D We can fix arbitrary horizontal boxes by redefining the 
%D \TEX\ primitive \type{\hbox}:
%D
%D \starttypen
%D \let\normalhbox=\hbox
%D
%D \def\hbox%
%D   {\ifmmode\mbox\else\normalhbox\fi}
%D \stoptypen
%D
%D with
%D
%D \starttypen
%D \def\mbox#1#%
%D   {\normalhbox#1\bgroup\mf\let\next=}
%D \stoptypen
%D
%D or more robust, that is, also accepting \type{\hbox\bgroup}:
%D
%D \starttypen
%D \def\mbox%
%D   {\normalhbox\bgroup\mf
%D    \dowithnextbox{\box\nextbox\egroup}%
%D    \normalhbox}
%D \stoptypen
%D
%D And now:
%D
%D \startbuffer
%D $\bf x^2 + \hbox{whatever} + \sin(2x)$
%D \stopbuffer
%D
%D \typebuffer
%D
%D Indeed gives:
%D
%D \startvoorbeeld
%D \enablembox\haalbuffer
%D \stopvoorbeeld
%D
%D But, do we want this kind of trickery to be activated? No,
%D simply because we cannot be sure of incompatibilities,
%D although for instance unboxing goes ok. Therefore we
%D introduce:

\def\normalmbox%
  {\normalhbox\bgroup\mf
   \dowithnextbox{\box\nextbox\egroup}\normalhbox}

\def\mbox%
  {\ifmmode\normalmbox\else\normalhbox\fi}

\def\enablembox%
  {\appendtoks
     \ifx\normalhbox\undefined\let\normalhbox=\hbox\fi
     \let\hbox=\mbox
   \to\everymath}

%D So in fact one can enable this feature if needed. I would say:
%D go along, but use grouping if needed!

%D \macros
%D   {mrfam,mifam,syfam,exfam,
%D    bsfam,bifam,scfam,tffam,
%D    mafam,mbfam,msfam}
%D
%D After this short mathematical excursion, we enter the world
%D of fonts and fontswitching. We start with something very
%D \TEX: \type{\fam} specified font families. \TEX\ uses
%D families for managing fonts in math mode. Such a family has
%D three members: text, script and scriptscript: $x^{y^z}$. In
%D \CONTEXT\ we take a bit different approach than \PLAIN\
%D \TEX\ does. \PLAIN\ \TEX\ needs at least four families for
%D typesetting math. We use those but give them symbolic names.

\chardef\mrfam=0   %  0  (Plain TeX)  Math Roman
\chardef\mifam=1   %  1  (Plain TeX)  Math Italic
\chardef\syfam=2   %  2  (Plain TeX)  Math Symbol
\chardef\exfam=3   %  3  (Plain TeX)  Math Extra

%D \PLAIN\ \TEX\ also defines families for {\it italic}, {\sl
%D slanted} and {\bf bold} typefaces, so we don't have to
%D define them here.
%D
%D \starttypen
%D \itfam  %  4  (Plain TeX)  Italic
%D \slfam  %  5  (Plain TeX)  Slanted
%D \bffam  %  6  (Plain TeX)  Boldface
%D \stoptypen
%D
%D Family~7 in \PLAIN\ \TEX\ is not used in \CONTEXT, because
%D we do massive switches from roman to sans serif, teletype or
%D other faces.
%D
%D \starttypen
%D \ttfam  %  7  (Plain TeX)  can be reused!
%D \stoptypen
%D
%D We define ourselves some more families for {\bs bold
%D slanted}, {\bi bold italic} and {\sc Small Caps}, so
%D we can use them in math mode too. Instead of separate
%D families for {\ss sans serif} and \type{teletype} we use the
%D more general \type{\tffam}, which stands for typeface.

\newfam\bsfam  %  8  (ConTeXt)  BoldSlanted
\newfam\bifam  %  9  (ConTeXt)  BoldItalic
\newfam\scfam  %  A  (ConTeXt)  SmallCaps
\newfam\tffam  %  B  (ConTeXt)  TypeFace

%D Because Taco needs a few more math families, we reuse
%D family~7 for all those typefaces that have no related
%D family, and therefore are grouped into one.

\let\nnfam\ttfam  %  7  (ReUsed)   NoName

%D Normally \type{\mrfam} equals \type{\tffam}, but a more
%D distinctive alternatives are possible, for instance the
%D Euler and Concrete Typefaces.
%D
%D After having defined all those in nature non||mathematical
%D families, we define ourselves some real math ones. These are
%D needed for the \AMS\ Symbol Fonts and Extended Lucida
%D Bright.

\newfam\mafam  %  C  (ConTeXt)  Math A Fam (AmsTeX A)
\newfam\mbfam  %  D  (ConTeXt)  Math B Fam (AmsTeX B)
\newfam\mcfam  %  E  (ConTeXt)  Math C Fam

%D Because there are 16~families and because \type{\ttfam}
%D is reused, at the moment we have one families left:~F.
%D
%D To ease the support of font packages, we als define
%D shortcuts to these familynames. This is necessary because
%D the family names are in fact \type{\chardef}'s, which means
%D that we're dealing with numbers (one can check this by
%D applying \type{\showthe} and \type{\show}). In the
%D specification of math symbols however we need hexadecimal
%D numbers, so we have to convert the \type{\fam}'s value.

\def\hexnumber#1%
  {\ifcase#1 0\or 1\or 2\or 3\or 4\or 5\or 6\or 7\or
             8\or 9\or A\or B\or C\or D\or E\or F\fi}

\edef\hexmrfam {\hexnumber\mrfam}  \edef\hexbsfam {\hexnumber\bsfam}
\edef\hexmifam {\hexnumber\mifam}  \edef\hexbifam {\hexnumber\bifam}
\edef\hexsyfam {\hexnumber\syfam}  \edef\hexscfam {\hexnumber\scfam}
\edef\hexexfam {\hexnumber\exfam}  \edef\hextffam {\hexnumber\tffam}
\edef\hexitfam {\hexnumber\itfam}  \edef\hexmafam {\hexnumber\mafam}
\edef\hexslfam {\hexnumber\slfam}  \edef\hexmbfam {\hexnumber\mbfam}
\edef\hexbffam {\hexnumber\bffam}  \edef\hexmcfam {\hexnumber\mcfam}

\edef\hexnnfam {\hexnumber\nnfam}

%D \macros 
%D   {lchexnumber,uchexnumber,lchexnumbers}
%D
%D In addition to the uppercase hex conversion, we
%D occasionally need a lowercase one, for instance when we
%D want to compose gbsong fontnames.

\def\lchexnumber#1%
  {\ifcase#1 0\or 1\or 2\or 3\or 4\or 5\or 6\or 7\or
             8\or 9\or a\or b\or c\or d\or e\or f\fi}

\let\uchexnumber=\hexnumber

\def\lchexnumbers#1%
  {\ifcase#1
     00\or 01\or 02\or 03\or 04\or 05\or 06\or 07\or 08\or 09\or 0a\or 0b\or 0c\or 0d\or 0e\or 0f\or
     10\or 11\or 12\or 13\or 14\or 15\or 16\or 17\or 18\or 19\or 1a\or 1b\or 1c\or 1d\or 1e\or 1f\or
     20\or 21\or 22\or 23\or 24\or 25\or 26\or 27\or 28\or 29\or 2a\or 2b\or 2c\or 2d\or 2e\or 2f\or
     30\or 31\or 32\or 33\or 34\or 35\or 36\or 37\or 38\or 39\or 3a\or 3b\or 3c\or 3d\or 3e\or 3f\or
     40\or 41\or 42\or 43\or 44\or 45\or 46\or 47\or 48\or 49\or 4a\or 4b\or 4c\or 4d\or 4e\or 4f\or
     50\or 51\or 52\or 53\or 54\or 55\or 56\or 57\or 58\or 59\or 5a\or 5b\or 5c\or 5d\or 5e\or 5f\or
     60\or 61\or 62\or 63\or 64\or 65\or 66\or 67\or 68\or 69\or 6a\or 6b\or 6c\or 6d\or 6e\or 6f\or
     70\or 71\or 72\or 73\or 74\or 75\or 76\or 77\or 78\or 79\or 7a\or 7b\or 7c\or 7d\or 7e\or 7f\or
     80\or 81\or 82\or 83\or 84\or 85\or 86\or 87\or 88\or 89\or 8a\or 8b\or 8c\or 8d\or 8e\or 8f\or
     90\or 91\or 92\or 93\or 94\or 95\or 96\or 97\or 98\or 99\or 9a\or 9b\or 9c\or 9d\or 9e\or 9f\or
     a0\or a1\or a2\or a3\or a4\or a5\or a6\or a7\or a8\or a9\or aa\or ab\or ac\or ad\or ae\or af\or
     b0\or b1\or b2\or b3\or b4\or b5\or b6\or b7\or b8\or b9\or ba\or bb\or bc\or bd\or be\or bf\or
     c0\or c1\or c2\or c3\or c4\or c5\or c6\or c7\or c8\or c9\or ca\or cb\or cc\or cd\or ce\or cf\or
     d0\or d1\or d2\or d3\or d4\or d5\or d6\or d7\or d8\or d9\or da\or db\or dc\or dd\or de\or df\or
     e0\or e1\or e2\or e3\or e4\or e5\or e6\or e7\or e8\or e9\or ea\or eb\or ec\or ed\or ee\or ef\or
     f0\or f1\or f2\or f3\or f4\or f5\or f6\or f7\or f8\or f9\or fa\or fb\or fc\or fd\or fe\or ff\fi}

%D \macros
%D   {uchar}
%D
%D This macro prepares \CONTEXT\ for \UNICODE\ support. By 
%D defining it here, we have at least an safeguard for utility 
%D file reading. 

\unexpanded\def\uchar#1#2{[#1,#2]}

%D We define some (very private) constants to improve speed,
%D memory usage and consistency.

\def\@size@       {@f@si@} % bodyfont size prefix (12pt etc)
\def\@style@      {@f@st@} % full style prefix (roman etc)
\def\@shortstyle@ {@f@sh@} % short style prefix (rm etc)
\def\@letter@     {@f@le@} % first alternative typeface
\def\@noletter@   {@f@no@} % second alternative typeface

%D We also define a list of all text (i.e.\ non math symbol)
%D families. I considered using something like: By assigning 
%D \type{\dowithfamily} some suitable meaning one can process 
%D such lists quite fast. The current implementation uses the
%D commalist processing macros and is not that slow either.

\def\familylist%
  {\c!tf,\c!sl,\c!it,\c!bf,\c!bs,\c!bi,\c!sc}

\def\processfamilylist%
  {\dowithfamily\c!tf
   \dowithfamily\c!sl
   \dowithfamily\c!it
   \dowithfamily\c!bf
   \dowithfamily\c!bs
   \dowithfamily\c!bi
   \dowithfamily\c!sc}

%D This list will be extended when needed with (pseudo)
%D families. The speude ones will in fact use the NoName
%D family.

%D All used styles, like rm, ss and tt, are saved in a comma
%D separated list. Appart from practical limitations one can
%D define as many styles as needed, but first we

\let\stylelist=\empty

%D \macros
%D   {magfactor,magfactorhalf}
%D
%D There are several ways to specify a font. Three of them are
%D pure \TeX\ ones, the fourth one is new:
%D
%D \starttypen
%D \font\name=cmr12
%D \font\name=cmr12 at 10pt
%D \font\name=cmr12 scaled \magstep2
%D \font\name=cmr12 sa 1.440
%D \stoptypen
%D
%D The non||\TEX\ alternative \type{sa} stands for {\em scaled
%D at}. This means as much as: scale the bodyfontsize with this
%D factor. The value 1.440 in this example is derived
%D from the \type{\magstep}'s as mentioned in
%D \in{table}[tab:magstep]. We therefore introduce
%D \type{\magfactor} as an alternative for \type{\magstep}.
%D
%D \plaatstabel[hier][tab:magstep]
%D   {Factors to be used with \type{sa.}}
%D \starttabel[|c|c|c|]
%D \HL
%D \NC \bf magstep \NC \bf equivalent     \NC \bf factor \NC\SR
%D \HL
%D \NC 1           \NC \type{\magfactor1} \NC 1.200      \NC\FR
%D \NC 2           \NC \type{\magfactor2} \NC 1.440      \NC\MR
%D \NC 3           \NC \type{\magfactor3} \NC 1.728      \NC\MR
%D \NC 4           \NC \type{\magfactor4} \NC 2.074      \NC\MR
%D \NC 5           \NC \type{\magfactor5} \NC 2.488      \NC\LR
%D \HL
%D \stoptabel

\def\magfactor#1%
  {\ifcase#1 1.000\or 1.200\or 1.440\or 1.728\or 2.074\or 2.488\or 1\fi}

\def\magfactorhalf%
  {1.095}

%D These macros enable the use of definitions like \type{sa
%D \magfactor3} which saves us both (mis|)|calculations and
%D potential mistypings.
%D
%D Because \type{sa} is not a \TEX\ supported alternative, we
%D have to test for it ourselves. In doing so, we need an
%D auxiliary \DIMENSION. We cannot use \type{\scratchdimen}
%D because font loading can happen at any moment due to
%D postponed loading. We could instead have used dirty grouping
%D tricks, but this one works too.

\newdimen\scaledfont

% \def\docalculatefont#1 sa #2sa#3*#4*#5*% The spaces are needed!
%   {\edef\fontscale{#2}%
%    \ifx\fontscale\empty
%      \expandafter\font\csname#4#5\endcsname=#1\relax
%    \else
%      \scaledfont=#4\relax
%      \expandafter\font\csname#4#5\endcsname=#1 at \fontscale\scaledfont\relax
%    \fi}

\def\splitfontdefinition#1 #2 #3 #4\end%
  {\def\somefontname{#1}%
   \doifelse{#2}{*}
     {\let\somefontspec=\empty}
     {\def\somefontspec{ #2 #3}}}

% \def\docalculatefont#1 sa #2sa#3*#4*#5*% The spaces are needed!
%   {\edef\fontscale{#2}%
%    \expandafter\splitfontdefinition#1 * * \end
%    \ifx\fontscale\empty \else
%      \scaledfont=#4\relax
%      \def\somefontspec{ at \fontscale\scaledfont}%
%    \fi
%    \expandafter\font\csname#4#5\endcsname=
%      \truefilename{\somefontname}\somefontspec\relax}

%D We also accept \type{sa a}||\type{sa d} as specification.

\def\checkfontscale#1#2\end%
  {\doifnumberelse{#1}{}
     {\doifdefinedelse{\??ft\s!default#1}
        {\edef\fontscale{\getvalue{\??ft\s!default#1}}}
        {\edef\fontscale{1}}}}

% \def\docalculatefont#1 sa #2sa#3*#4*#5*% The spaces are needed!
%   {\edef\fontscale{#2}%
%    \expandafter\splitfontdefinition#1 * * \end
%    \ifx\fontscale\empty \else
%      \expandafter\checkfontscale#2 \end % #2 can be "a " (space!)
%      \scaledfont=#4\relax
%      \def\somefontspec{ at \fontscale\scaledfont}%
%    \fi
%    \expandafter\font\csname#4#5\endcsname=
%      \truefilename{\somefontname}\somefontspec\relax}

\def\defaultfontfile{cmtt10}
\edef\nullfontname  {\fontname\nullfont}
\edef\dummyfontname {font\strippedcsname\\}

\def\docalculatefont#1 sa #2sa#3*#4*#5*% The spaces are needed!
  {\edef\fontscale{#2}%
   \expandafter\splitfontdefinition#1 * * \end
   \ifx\fontscale\empty \else
     \expandafter\checkfontscale#2 \end % #2 can be "a " (space!)
     \scaledfont=#4\relax
     \def\somefontspec{ at \fontscale\scaledfont}%
   \fi
   \edef\fontfile{\truefontname\somefontname}%
   \ifx\fontfile\s!unknown
     \let\fontfile\defaultfontfile
   \else 
     \edef\fontdata{\truefontdata\somefontname}%
     \ifx\fontdata\empty \else
      %\@EA\getparameters\@EA[\@EA\fontfile\@EA]\@EA[\fontdata]%
       \@EA\rawgetparameters\@EA[\@EA\fontfile\@EA]\@EA[\fontdata]%
     \fi
   \fi
   % faster 
   %\expandafter\font\csname#4#5\endcsname\fontfile\somefontspec\relax
   % nicer
   \edef\lastfontname{\fontfile\somefontspec}%
   \expandafter\font\csname#4#5\endcsname\lastfontname
   \expandafter\font\csname\dummyfontname\endcsname\lastfontname\relax}
   % safer but sometimes introducing newlines in the log 
   %\batchmode
   %\font\lastloadedfont\fontfile\somefontspec\relax
   %\errorstopmode
   %\edef\lastfontname{\fontname\lastloadedfont}%
   %\ifx\lastfontname\nullfontname
   %  \showmessage{\m!fonts}{10}{\fontfile}%
   %  \expandafter\font\csname#4#5\endcsname=\defaultfontfile\somefontspec\relax
   %\else
   %  \expandafter\let\csname#4#5\endcsname\lastloadedfont
   %\fi}

%D The duplicate font definition, using the ever the same dummy
%D font name, results in less fuzzy error messages. In the log
%D file, for instance when overfull boxes are reported, the
%D simple keyword `font' replaces the \TEX\ ordinated name. The
%D latter can be too misleading, due to the fact that \TEX\ has
%D a rather optimized font memory management. Thanks to Taco 
%D for helping me sort this out.

%D \macros
%D   {definefontsynonym}
%D
%D While looking for fonts, fontsynonyms are used for accessing
%D the files!
%D
%D \starttypen
%D \definefontsynonym[Serif][Lucida-Bright]
%D \definefontsynonym[Lucida-Bright][lbr][encoding=texnansi]
%D \stoptypen
%D
%D The definitions can be accessed by:
%D
%D \startregels
%D name: \type {\truefontname{Lucida-Bright}}
%D data: \type {\truefontdata{Lucida-Bright}}
%D \stopregels

\def\definefontsynonym%
  {\dotripleempty\dodefinefontsynonym}

\def\dodefinefontsynonym[#1][#2][#3]%
  {\setevalue{\??ff#1}{{#2}{#3}}}

\def\truefontname#1%
  {\dotruefontname{#1}{}}

\def\dotruefontname#1#2%
  {\ifundefined{\??ff#1}%
     #1%
   \else
     \@EA\@EA\@EA\dotruefontname\csname\??ff#1\endcsname
   \fi}

\def\truefontdata#1%
  {\dotruefontdata{#1}{}}

\def\dotruefontdata#1#2%
  {\ifundefined{\??ff#1}%
     #2%
   \else
     \@EA\@EA\@EA\dotruefontdata\csname\??ff#1\endcsname
   \fi}

%D \macros
%D   {getfontfileparameters}
%D
%D For special purposes, one can use the next macro to 
%D access font file characteristics, for instance:
%D
%D \starttypen
%D \getfontfileparameters{Regular}
%D \stoptypen
%D
%D can result in: 
%D
%D \starttypen
%D \def\currentfontfileencoding{texnansi}
%D \stoptypen

\def\getfontfileparameters#1%
  {\edef\fontdata{\truefontdata{#1}}%
   \expanded{\getparameters[currentfontfile][\fontdata]}}

%D \macros
%D   {definefont}
%D
%D Before we implement the main definition macro, we first show
%D one for local use:
%D
%D \starttypen
%D \definefont[Some][LucidaBright at 100pt]    \Some some text
%D \definefont[More][LucidaBright scaled 3000] \More more text
%D \definefont[Last][LucidaBright sa 5.4]      \Last last text
%D \stoptypen
%D
%D The implementation one looks familiar:

\def\definefont%
  {\dodoubleargument\dodefinefont}

% \def\dodefinefont[#1][#2]% 
%   {\unexpanded\setvalue{#1}{\dododefinefont{#1}#2 sa sa*}}
%
% A more friendly version, which defaults to \type {sa 1} is: 

\def\dodefinefont[#1][#2]% 
  {\doifinstringelse{ }{#2}
     {\unexpanded\setvalue{#1}{\dododefinefont{#1}#2 sa sa*}}
     {\dodefinefont[#1][#2 sa 1]}}

\def\dododefinefont#1#2sa #3sa#4*%
  {\edef\fontscale{#3}%
   \expandafter\splitfontdefinition#2 * * \end
   \expandafter\font\csname#1\endcsname=\truefontname\somefontname
     \ifx\fontscale\empty
       \somefontspec
     \else
       \space at \fontscale\bodyfontsize
     \fi
   \getvalue{#1}}

%D I considered checking for mistakenly use of \PLAIN's
%D \type{\magstep}'s but although it would take only a few
%D lines of code, this would not add to consistent use. I
%D therefore removed this check. Here we also handle the
%D optional hyphenchar definitions, like:
%D
%D \starttypen
%D \definebodyfont [12pt] [rm] [hyphenchar=45]
%D \stoptypen

\beginTEX

\def\dodoloadfont#1#2#3#4%
  {\edef\calculatedfont{\csname\??ft#1#2#3\endcsname\space}%
   \expandafter\docalculatefont\calculatedfont sa sa*#1*#2#3*%
   \@EA\hyphenchar\csname#1#2#3\endcsname=
     \@EA\ifx\csname\??ft#1#2\s!hyphenchar\endcsname\relax
       #4%
     \else
       \csname\??ft#1#2\s!hyphenchar\endcsname
     \fi\relax
   \csname#1#2#3\endcsname}

\endTEX

\beginETEX \ifcsname

\def\dodoloadfont#1#2#3#4%
  {\edef\calculatedfont{\csname\??ft#1#2#3\endcsname\space}%
   \expandafter\docalculatefont\calculatedfont sa sa*#1*#2#3*%
   \@EA\hyphenchar\csname#1#2#3\endcsname=
     \ifcsname\??ft#1#2\s!hyphenchar\endcsname
       \csname\??ft#1#2\s!hyphenchar\endcsname
     \else
       #4%
     \fi\relax
   \csname#1#2#3\endcsname}

\endETEX

%D The loading macro is used in two macros. One of them takes
%D care of fixed width teletype fonts.

\def\doloadfont#1#2#3%
  {%\debuggerinfo{\m!fonts}{loaded #1#2#3}%
   \dodoloadfont{#1}{#2}{#3}{45}}

\def\doloadttfont#1#2#3%
  {%\debuggerinfo{\m!fonts}{loaded fixed #1#2#3}%
   \dodoloadfont{#1}{#2}{#3}{-1}}

%D \macros
%D   {getfontname}
%D
%D The names of the fonts can be called with the rather simple
%D macro \type{\getfontname}. When for instance we pass
%D \type{12ptrmtf} as argument, we get \getfontname{12ptrmtf}.

\def\getfontname#1%
  {\getvalue{\??ft#1}}

%D \macros 
%D   {currentfontscale}
%D
%D Sometimes we need to have access to the font scale 
%D including the \type{a}||\type{d} sizes. The next macro 
%D returns the current scaling factor. Take a look at 
%D \type {cont-log.tex} for an example of its use. 

\beginTEX

\def\currentfontscale%
  {\@EA\ifx\csname\??ft\s!default\xfontsize\endcsname\relax
     \@EA\ifx\csname\??ft\s!default\s!text\endcsname\relax
       1%
     \else
       \csname\??ft\s!default\s!text\endcsname
     \fi
   \else
     \csname\??ft\s!default\xfontsize\endcsname
   \fi}

\endTEX

\beginETEX \ifcsname

\def\currentfontscale%
  {\ifcsname\??ft\s!default\xfontsize\endcsname
     \csname\??ft\s!default\xfontsize\endcsname
   \else\ifcsname\??ft\s!default\s!text\endcsname
     \csname\??ft\s!default\s!text\endcsname
   \else
     1%
   \fi\fi}

\endETEX

%D Both alternatives use \type {\xfontsize}, a macro that
%D expands to the current size in terms of \type {a} \unknown
%D \type {d}, nothing, or \type {x} \unknown \type {xx}. 

\def\xfontsize{\ifcase\currentxfontsize\fontsize\or\c!x\else\c!xx\fi}

%D A typical use of this command is in commands that switch 
%D to another font bypassing the font mechanism: 
%D 
%D \starttyping 
%D \font\myfont=\truefontname{MyFont} at \currentfontscale\bodyfontsize
%D \stoptyping 

%D Now we enter the area of font switching. The switching
%D mechanism has to take care of several situations, like:
%D
%D \startopsomming[opelkaar]
%D \som  changing the overal document fonts (including margins,
%D       headers and footers)
%D \som  changing local fonts (only the running text)
%D \som  smaller and even more smaller alternatives (super-
%D       and subscripts)
%D \stopopsomming
%D
%D \TEX\ offers a powerfull family mechanism for super- and
%D subscripts in math mode. In text mode however, we don't use
%D families for the smaller alternatives, and therefore have
%D to take care of it otherwise.

%D \macros
%D   {definebodyfontenvironment,setupbodyfontenvironment}
%D
%D The relationship between the several sizes of a font, is
%D defined by:
%D
%D \showsetup{\y!definebodyfontenvironment}
%D
%D Later on we will see how these parameters are used, so for
%D the moment we stick with an example:
%D
%D \starttypen
%D \definebodyfontenvironment
%D   [12pt]
%D   [        text=12pt,
%D          script=9pt,
%D    scriptscript=7pt,
%D               x=10pt,
%D              xx=8pt,
%D             big=12pt,
%D           small=10pt]
%D \stoptypen
%D
%D The first argument specifies the bodyfont size to which the
%D settings apply. All second parameters are specified in
%D dimensions and tell us more about related sizes.
%D
%D Afterwards, one can change values with 
%D
%D \showsetup{\y!setupbodyfontenvironment}
%D
%D Due to the fact that \type{\c!text} and \type{\s!text} can
%D have a similar meaning, and therefore can lead to an
%D unwanted loop, we temporary redefine \type{\c!text}. For
%D the moment this in only place that some trickery is needed
%D to fool the multilingual interface.
%D
%D When instead of a size the keyword \type{unknown} is
%D passed, fractions (relations) are used instead of fixed
%D sizes.

\let\bodyfontenvironmentlist\empty

\def\definebodyfontenvironment%
  {\dodoubleempty\dodefinebodyfontenvironment}

\newcount\@@fontdefhack

\def\@@beginfontdef%
  {\ifcase\@@fontdefhack
     \let\k!savedtext     =\k!text      \let\k!text     =\s!text  
     \let\k!k!savedtext   =\k!k!text    \def\k!k!text    {1}%
     \let\k!saveddefault  =\k!default   \let\k!default  =\s!default
     \let\k!k!saveddefault=\k!k!default \def\k!k!default {1}%
   \fi
   \advance\@@fontdefhack by 1 }

\def\@@endfontdef%
  {\advance\@@fontdefhack by -1
   \ifcase\@@fontdefhack
     \let\k!k!default=\k!k!saveddefault
     \let\k!default  =\k!saveddefault
     \let\k!k!text   =\k!k!savedtext
     \let\k!text     =\k!savedtext
   \fi}

\def\dodefinebodyfontenvironment[#1][#2]%
  {\@@beginfontdef
   \doifelse{#1}{\s!default}
     {\getparameters[\??ft\s!default][#2]}
     {\normalizebodyfontsize#1\to\tempbodyfontsize
      \addtocommalist\tempbodyfontsize\bodyfontenvironmentlist
      \@EA\dododefinebodyfontenvironment\@EA[\tempbodyfontsize][#2]}%
   \@@endfontdef}

\def\dododefinebodyfontenvironment[#1][#2]%
  {\doifundefined{\??ft#1\s!text}
     {\def\docommando##1%
        {\scratchdimen=#1\relax
         \scratchdimen=\getvalue{\??ft\s!default##1}\scratchdimen
         \normalizebodyfontsize\scratchdimen\to\tempbodyfontsize
         \setevalue{\??ft#1##1}{\tempbodyfontsize}}%
      \processcommalist
        [\s!text,\s!script,\s!scriptscript,\c!x,\c!xx,\c!groot,\c!klein]
        \docommando
      \copyparameters
        [\??ft#1][\??ft\s!default]
        [\c!interlinie,\c!em]}%
   \@@beginfontdef
   \getparameters[\??ft#1][#2]%
   \@@endfontdef
   \setvalue{\@size@#1}{\docompletefontswitch[#1]}}

\def\setupbodyfontenvironment%
  {\dodoubleargument\dosetupbodyfontenvironment}

\def\dosetupbodyfontenvironment[#1][#2]%
  {\@@beginfontdef
   \getparameters[\??ft#1][#2]%
   \@@endfontdef}

%D We default all parameters to the main bodyfont size (begin
%D \type{#1}), so the next setup is valid too:
%D
%D \starttypen
%D \definebodyfontenvironment[24pt]
%D \stoptypen
%D
%D All parameters can be redefined when needed, so one does
%D not have to stick to the default ones.

%D \macros
%D   {definebodyfont}
%D
%D The next step in defining a bodyfont involves the actual font
%D files, which can be recognized by their extension
%D \type{tfm}. Installing those file is often beyond the
%D scope of the user and up to the system administrator.
%D
%D \showsetup{\y!definebodyfont}
%D
%D This commands takes three arguments, where \ShowArgument\
%D takes a (series of) bodyfont size(s) and \ShowArgument\
%D the style group to which the definitions belong.
%D
%D Argument \ShowArgument\ accepts any suitable alternative,
%D as specified by the \TEX\ families, extended with~a, b~and
%D higher sizes or the normal \TEX\ mathematical families and
%D some more.
%D
%D We show two examples, that show all the alternative
%D scaling options. The \type{\tfa} alternatives can be
%D extended with \type{\bfa}, \type{\slb}, etc. or even
%D \type{e} and higher alternatives.
%D
%D \starttypen
%D \definebodyfont [12pt] [rm]
%D   [tf=cmr12,
%D    bf=cmbx12,
%D    it=cmti12,
%D    sl=cmsl12,
%D    bi=cmbxti10 at 12pt,
%D    bs=cmbxsl10 at 12pt,
%D   tfa=cmr12    scaled \magstep1,
%D   tfb=cmr12    scaled \magstep2,
%D   tfc=cmr12    scaled \magstep3,
%D   tfd=cmr12    scaled \magstep4,
%D    sc=cmcsc10  at 12pt]
%D
%D \definebodyfont [12pt,11pt,10pt,9pt,8pt] [rm]
%D   [tf=lbr  sa 1,
%D    bf=lbd  sa 1,
%D    it=lbi  sa 1,
%D    sl=lbsl sa 1,
%D    bi=lbdi sa 1,
%D    bs=lbdi sa 1,
%D   tfa=lbr  sa 1.200,
%D   tfb=lbr  sa 1.440,
%D   tfc=lbr  sa 1.728,
%D   tfd=lbr  sa 2.074,
%D    sc=lbr  sa 0.833]
%D \stoptypen
%D
%D The second example shows that we can define more sizes at
%D once. The main difference between these examples is that the
%D Computer Modern Roman come in many design sizes. This means
%D that there we cannot define them in bulk using \type{sa}.
%D Instead of \type{rm} (roman) one can define \type{ss} (sans
%D serif), \type{tt} (teletype), \type{hw} (hand written),
%D \type{cg} (calygraphic) and whatever styles.

\def\definebodyfont%
  {\dotripleargument\dodefinebodyfont}

%D The first argument may be a comma separated list. This,
%D combined with specifications using \type{sa} can save a lot
%D of typing. Although all arguments should be specified, we
%D treat the second argument as optional.

%\def\dodefinebodyfont[#1][#2][#3]%
%  {\ifthirdargument
%     \def\dododefinebodyfont##1%
%       {\dodododefinebodyfont[##1][#2][#3]}%
%     \processcommalist[#1]\dododefinebodyfont
%   \else
%     \definebodyfont[#1][\c!rm][#2]%
%   \fi}

\def\dodefinedefaultbodyfont[#1][#2]%
  {\def\dododefinedefaultbodyfont##1%
     {\def\dodododefinedefaultbodyfont####1{\getvalue{\s!default####1}{##1}}%
      \processcommalist[#2]\dodododefinedefaultbodyfont}%
   \processcommalist[#1]\dododefinedefaultbodyfont}

\def\dodefinebodyfont[#1][#2][#3]%
  {\ifthirdargument
     \doifelse{#3}{\s!default} % new 
       {\dodefinedefaultbodyfont[#1][#2]}
       {\def\dododefinebodyfont##1{\dodododefinebodyfont[##1][#2][#3]}%
        \processcommalist[#1]\dododefinebodyfont}%
   \else\ifsecondargument
     \definebodyfont[#1][\c!rm][#2]%
   \else
     \doifundefined{\@size@#1} % Maybe there are default dependancies
       {\defineunknownfont{#1}}% defined which we can use ([unknown])
     \doifundefined{\@size@#1} % and if not, then we have at least to
       {\definebodyfont[#1][\c!rm][]}% make sure some basics are set up.
   \fi\fi}

%D Defining a bodyfont involves two actions: defining the specific
%D style related alternatives, like \type{\rma}, \type{\bfa}
%D and \type{\rmsla}, and storing the definitions of their
%D bodyfont size related fonts. The first step is bodyfont
%D independant but executed every time. This permits user
%D definitions like \type{\tfw} or \type{\bfq} for real large
%D alternatives.

\def\dodododefinebodyfont[#1][#2][#3]% er kan wat naar buiten
  {\doifelse{#1}{\s!default}
     {\setvalue{\s!default#2}##1{\definebodyfont[##1][#2][#3]}}
     {\geteparameters[\??ft#1#2][#3]% We expand them!
      \dodefinebodyfontenvironment[#1][]% Just to be sure.
      \def\doiffamily##1##2##3\\% adapted
        {\doifinstringelse{##1##2}\familylist
           {}
           {\addtocommalist{##1##2}\familylist
            %\settextfonts
            \unexpanded\setvalue{##1##2}%
              {\getvalue{#2}\getvalue{##1##2}}%
            \unexpanded\setvalue{##1##2\c!x}%
              {\getvalue{##1##2}\getvalue{##1##2\c!x}}%
            \unexpanded\setvalue{##1##2\c!xx}%
              {\getvalue{##1##2}\getvalue{##1##2\c!xx}}}%
         \doifsomething{##3} 
           {\unexpanded\setvalue{#2##3}% eg: \rma, \ssa
              {\switchtofontstyle{#2}{##3}}%
            \unexpanded\setvalue{##1##2##3}% eg: \tfa, \bfa
              {\switchtofontalternative{##1##2}{##3}}%
            \unexpanded\setvalue{#2##1##2##3}% eg: \rmtfa, \ssbfa
              {\switchtofontstylealternative{#2}{##1##2}{##3}}}}%
      \def\dododododefinebodyfont##1%
        {\doifnot{##1}{\s!hyphenchar}
           {\doifdefined{\??ft#1#2##1}
              {%\letvalue{@#1#2##1@}=\characterencoding
               \setevalue{@#1#2##1@}{\currentencoding}% strips @ 
               \doifelse{#2}{\c!tt}
                 {\unexpanded\setvalue{#1#2##1}{\doloadttfont{#1}{#2}{##1}}}
                 {\unexpanded\setvalue{#1#2##1}{\doloadfont{#1}{#2}{##1}}}%
               \bgroup
               \let\relax=\empty
              %\debuggerinfo
              %  {\m!fonts}{\getvalue{\??ft#1#2##1} defined as #1 #2 ##1}%
               \egroup}%
            \doifnot{#2}{\c!mm}  % new!
              {\expandafter\doiffamily##1\\}}}%
      \processassignlist[#3]\dododododefinebodyfont}}

%D Unknown families are added to the family list! For the
%D moment we also set the direct calls here. Some day a better
%D solution will be implemented. The good news is that unknown
%D fonts are defined automatically.

\newif\ifdefiningunknownfont

\def\defineunknownfont#1% 
  {\let\c!savedtext=\c!text
   \let\c!text=\s!text
   \donefalse
   \def\docommando##1%
     {\doifdefined{\??ft\s!default##1}
        {\donetrue
         \scratchdimen=#1\relax
         \scratchdimen=\getvalue{\??ft\s!default##1}\scratchdimen
        %\setevalue{\??ft#1##1}{\the\scratchdimen}}}%
         \normalizebodyfontsize\scratchdimen\to\!!stringa
         \letvalue{\??ft#1##1}\!!stringa}}%
   \processcommalist
     [\s!text,\s!script,\s!scriptscript,\c!x,\c!xx,\c!groot,\c!klein]
     \docommando
   \let\c!text=\c!savedtext
   \ifdone
     \donefalse
     \def\defineunknownbodyfont##1%
       {\doifdefined{\s!default##1}{\donetrue\getvalue{\s!default##1}{#1}}}%
     \processcommacommand
       [\stylelist,\c!mm]
       \defineunknownbodyfont
     \ifdone
       \setvalue{\@size@#1}{\docompletefontswitch[#1]}%
       \ifdefiningunknownfont \else
         \definingunknownfonttrue
         \def\defineunknownsubfont##1%
           {\doifundefined{\@size@\getvalue{\??ft#1##1}}
              {\defineunknownfont{\getvalue{\??ft#1##1}}}}%
         \processcommalist
           [\s!text,\s!script,\s!scriptscript,\c!x,\c!xx,\c!groot,\c!klein]
           \defineunknownsubfont
         \definingunknownfontfalse
       \fi
     \fi
   \fi}

%D These macros show that quite some definitions take place.
%D Fonts are not loaded yet! This means that at format
%D generation time, no font files are preloaded.
%D

% %D We could have use \type{\unexpanded\setvalue} instead of
% %D the \type{\donottest} prefixes. However, this would lead to
% %D about 600 extra entries in the hash table.

%D A previous implementation used: 
%D 
%D \starttypen
%D \type {\setvalue{name}{\donottest...}}
%D \stoptypen
%D 
%D instead of the more memory hungry:
%D
%D \starttypen
%D \unexpanded\setvalue{name}{...}
%D \stoptypen
%D
%D The first alternative saves about 500 hash entries (about
%D 2.5\% of the total number of entries used. The second 
%D alternative is currently used, because that one can more 
%D easily be made \ETEX\ aware. 

%D \macros
%D   {everybodyfont,Everybodyfont}
%D
%D Every change in bodyfont size has conseqences for the baseline
%D distance and skips between paragraphs. These are initialized
%D in other modules. Here we only provide the hooks that
%D garantees their handling.

\newevery \everybodyfont \Everybodyfont

%D At the system level one can initialize thing like:
%D
%D \starttypen
%D \appendtoks \setupspacing \to \everybodyfont
%D \stoptypen
%D
%D While users can add their own non standard commands like:
%D
%D \starttypen
%D \Everybodyfont{\message{changing to bodyfont \the\bodyfontsize}}
%D \stoptypen
%D
%D Personnaly I never felt the need for such extensions, but
%D at least its possible.

%D \macros
%D   {globalbodyfontsize,localbodyfontsize}
%D
%D Next we'll do the tough job of font switching. Here we
%D have to distinguish between the global (overal) bodyfont
%D size and the local (sometimes in the textflow) size. We
%D store these dimensions in two \DIMENSION\ registers.

\newdimen\globalbodyfontsize  \globalbodyfontsize=12pt
\newdimen\localbodyfontsize   \localbodyfontsize =\globalbodyfontsize

%D \macros
%D   {bodyfontsize}
%D
%D These two registers are not to be misused in calculations.
%D For this purpose we keep a copy:

\newdimen\bodyfontsize  \bodyfontsize=\globalbodyfontsize

%D \macros
%D   {outputresolution}
%D
%D Sometimes (to be honest: not in this module) we need to
%D take the system resolution into account. Therefore we also
%D define a macro:

\def\outputresolution {600}

%D \macros
%D   {bodyfontfactor,bodyfontpoints}
%D
%D For multiplication purposes we keep an auxiliary counter
%D and macro (here the expansion is not explicitly needed):

\newcount\bodyfontpoints \dimensiontocount\bodyfontsize\bodyfontpoints

\edef\bodyfontfactor{\withoutpt\the\bodyfontsize}

%D When we assign for instance 12pt to a \DIMENSION\ register
%D the \type{\the}'d value comes out as 12.0pt, which is
%D often not the way users specify the bodyfont size. Therefore
%D we also store the normalized value.

\chardef\fontdigits=1 % 

\def\donormalizedbodyfontsize#1.#2#3#4\to#5%
  {\edef#5%
     {#1%
      \ifcase\fontdigits\space
      \or
        \ifcase#2 \else.#2\fi % and not: \ifcase#2\else ...
      \else
        \ifcase#2#3 \else.#2\ifcase#3 \else#3\fi\fi % not: \ifcase#2#3\else ...
      \fi
      pt}}

\def\normalizebodyfontsize#1\to#2%
  {\scratchdimen=#1\relax
   \@EA\@EA\@EA\donormalizedbodyfontsize
     \@EA\WITHOUTPT\the\scratchdimen00\to#2}

\normalizebodyfontsize\bodyfontsize\to\normalizedglobalbodyfontsize
\normalizebodyfontsize\bodyfontsize\to\normalizedlocalbodyfontsize
\normalizebodyfontsize\bodyfontsize\to\normalizedbodyfontsize

%D To be internationalized:

\def\korpsgrootte {\bodyfontsize}
\def\korpspunten  {\bodyfontpoints}

%D some day.

%D \macros
%D   {fontsize,fontstyle}
%D
%D Within a bodyfont, fonts can come in different sizes. For
%D instance \type{\tf} is accompanied by \type{\tfa},
%D \type{\tfb} etc. The third character in these sequences
%D represents the size. The actual size is saved in a macro

\let\fontsize  = \empty

%D The style, being roman (\type{\rm}), sans serif (\type{\ss})
%D etc. is also available in a macro in \type{rm}, \type{ss}
%D etc. form:

\let\fontstyle = \empty

%D All things related to fonts are grouped into files with
%D names like \type{font-cmr}. These files are loaded by:

\def\resetfontdefinitionfile#1%
  {\letbeundefined{\c!file\f!fontprefix#1}}

\def\doreadfontdefinitionfile#1%
  {\doifundefined{\c!file\f!fontprefix#1}%
     {\setvalue{\c!file\f!fontprefix#1}{}%
      \makeshortfilename[\truefilename{\f!fontprefix#1}]%
      \startreadingfile
      \readsysfile{\shortfilename}
        {\showmessage{\m!fonts}{2}{#1}}
        {\loadfontmappingfile{#1}
           {\showmessage{\m!fonts}{9}{#1}}
           {\showmessage{\m!fonts}{3}{#1}}}%
      \stopreadingfile}}

%D Such files are only loaded once! This permits redundant
%D loading, but at the same time forced grouping when we want
%D continuously mix all kind of font, which of course is a kind
%D of typographically sin. The \type{"} is made inactive if
%D needed to prevent problems with loading files that use this
%D character in numbers.

\def\doswitchpoints[#1]%
  {\expanded{\dodoswitchpoints{#1}}}

% \def\dodoswitchpoints#1%
%   {\doifdefinedelse{\@size@#1}
%      {\getvalue{\@size@#1}%
%       \localbodyfontsize=#1\relax
%       \normalizebodyfontsize\localbodyfontsize\to\normalizedbodyfontsize
%       \the\everybodyfont}
%      {\showmessage{\m!fonts}{4}{#1}}}

\def\dodoswitchpoints#1%
  {\doifundefined{\@size@#1}
     {\defineunknownfont{#1}}%
   \doifdefinedelse{\@size@#1}
     {\getvalue{\@size@#1}%
      \localbodyfontsize=#1\relax
      \normalizebodyfontsize\localbodyfontsize\to\normalizedbodyfontsize
      \the\everybodyfont}
     {\showmessage{\m!fonts}{4}{#1}}}

\def\doswitchstyle[#1]%
  {\doifdefinedelse{\@style@#1}
     {\getvalue{\@style@#1}%
      \edef\fontstyle{#1}}
     {\showmessage{\m!fonts}{5}{#1}}}

%D \TEX\ loads font metric files like \type{cmr10.tfm} and
%D \type{tir.tfm} only once. In \PLAIN\ \TEX\ some font files
%D are {\em preloaded}. This means that the font files are
%D loaded, but not accessible yet by name. This is accomplished
%D by saying:
%D
%D \starttypen
%D \font\preloaded=cmr10 at 11pt
%D \stoptypen
%D
%D and using the name \type{\preloaded} again and again, so
%D fonts are indeed loaded, but unnamed, and therefore
%D unaccessible. In \CONTEXT\ we don't preload fonts, not even
%D the \PLAIN\ \TEX\ ones, although users can access them. Now
%D why is this done?

%D Defining fonts using \type{\definebodyfont} takes time, so we
%D prefer to predefine at least the Computer Modern Roman
%D fonts. However, loading all those fonts at definition time
%D would take both time and space. But even worse, once fonts
%D are loaded into memory, their encoding vector is fixed,
%D which is a handicap when we want to distribute the compact
%D \type{fmt} files. So what we want to do is defining fonts in
%D a way that postpones the loading. We accomplish this by only
%D loading the fonts when we switch to another bodyfont size.
%D Among the other alternatives, such as loading the font at
%D the moment of activation and redefining the activation
%D macro afterwards, this proved to be the most efficient
%D alternative.
%D
%D The next few macros take care of the one exeption on this
%D scheme. When at format generation time we load the default
%D font file, the one that defines the Computer Modern Fonts,
%D we don't want the fonts metrics to end up in the format
%D file, so we temporary prohibit loading. This means that at
%D runtime we have to load the default bodyfont size just before
%D we start typesetting.
%D
%D Therefore we have to signal the font switching macros that
%D we are preloading fonts. As long as the next boolean is,
%D true, no loading is done.

\newif\ifloadingfonts \loadingfontstrue

%D \macros
%D   {preloadfonts}
%D
%D Preloading is only called for once, during the startup
%D sequence of a session. After the loading job is done, the
%D macro relaxes itself and reset the signal.

\def\preloadfonts%
  {\showmessage{\m!fonts}{6}{\normalizedbodyfontsize\normalspace\fontstyle}%
   \doswitchpoints[\normalizedbodyfontsize]%
   \doswitchstyle[\fontstyle]%
   \global\let\preloadfonts=\relax
   \global\loadingfontsfalse}

%D Here comes the main font switching macros. These macros
%D handle changes in size as well as returning to the global
%D bodyfont size.

\def\dosetfont[#1]%
  {\doifelse{#1}{\v!globaal}
     {\restoreglobalbodyfont}
     {\processcommalist[#1]\dodosetfont
      \ifloadingfonts\else
        \doswitchpoints[\normalizedbodyfontsize]%
        \doswitchstyle[\fontstyle]%
      \fi}%
   \chardef\currentxfontsize=0\relax}

\def\dodosetfont#1%
  {\dododosetfont{#1}{\showmessage{\m!fonts}{4}{#1}}}

\def\dododosetfont#1#2%
  {\doifnumberelse{#1}
     {\scratchdimen=#1\relax
      \normalizebodyfontsize\scratchdimen\to\normalizedsetfont
      \doifundefined{\@size@\normalizedsetfont}
        {\defineunknownfont{#1}}%
      \doifdefinedelse{\@size@\normalizedsetfont}
        {\localbodyfontsize=\normalizedsetfont
         \let\normalizedbodyfontsize=\normalizedsetfont}
        {#2\dosetsubstitutefont{#1}}}
     {\doifelse{#1}{\v!reset}
        {\let\fontsize=\empty}
        {\doifdefinedelse{\@style@#1}
           {\edef\fontstyle{#1}}
           {\doreadfontdefinitionfile{#1}}}}}

%D In the previous macros we use \type{\currentxfontsize} to
%D hold the current x||size of the font. This enables us to
%D support for instance \type{\sl} inside a \type{\tx} switch.

\chardef\currentxfontsize=0

%D When users specify for instance a 13 point bodyfont while no
%D such bodyfont is defined, the system automatically tries to
%D find a best fit, that is the nearest smaller defined
%D bodyfontzize. A smaller one is definitely better than a larger
%D one, simply because otherwise a lot of overfull box messages
%D are more probable to occur. By taking a value slightly
%D smaller than half a point, we can use the next method.

\def\dosetsubstitutefont#1%
  {\scratchdimen=#1\relax
   \advance\scratchdimen by .499pt
   \dimensiontocount\scratchdimen\scratchcounter
   \advance\scratchcounter by -1
   \ifnum\scratchcounter>3
     \dododosetfont{\the\scratchcounter pt}{}%
   \fi}

%D Next we're going to implement some switching macros we
%D already used in when defining fonts. The first one takes
%D care of the style and is used by commands like \type{\rma}.

\def\switchtofontstyle#1#2%
  {\getvalue{#1}%
   \getvalue{\c!tf#2}}

%D The second one is responsible for commands like \type{\bfa}
%D and the third one handles the combined \type{\rmbfa}
%D alternatives.

\def\switchtofontalternative#1#2%
  {\def\fontsize{#2}%
   \setfontstyle{\fontstyle}{\fontstyle}%
   \getvalue{#1}}

\def\switchtofontstylealternative#1#2#3%
  {\getvalue{\normalizedbodyfontsize#1#2#3}}

%D Setting the normal sized as well as the x and xx smaller
%D sizes is accomplished by the next set of macros. When in
%D math mode, the commands \type{\tx} and \type{\txx} are
%D just a switch to the script and double script styles, but
%D in text mode the values defined by the bodyfontenvironment are
%D used. Here we also set \type{\currentxfontsize}.

\def\dosetsomextypeface#1%
  {\doifdefinedelse{#1}
     {\getvalue{#1}}
     {\showmessage{\m!fonts}{7}{#1}}}%

\def\dosetxtypeface#1%
  {\chardef\currentxfontsize=1
   \ifmmode
     \scriptstyle
   \else
     \dosetsomextypeface
       {\getvalue{\??ft\normalizedbodyfontsize\c!x}%  % pt
        \getvalue{\@shortstyle@\fontstyle}%           % rm
        #1}%                                          % tf
     \unexpanded\def\tx{\dosetxxtypeface{#1}}%
   \fi}

\def\dosetxxtypeface#1%
  {\chardef\currentxfontsize=2
   \ifmmode
     \scriptscriptstyle
   \else
     \dosetsomextypeface
       {\getvalue{\??ft\normalizedbodyfontsize\c!xx}%  % pt
        \getvalue{\@shortstyle@\fontstyle}%            % rm
        #1}%                                           % tf
     \let\tx=\relax
     \let\txx=\relax
   \fi}

%D These macros also show us that when we call for \type{\tx},
%D this macro is redefined to be \type{\txx}. Therefore calls
%D like:
%D
%D \startbuffer
%D {small \tx  is \tx  beautiful}
%D {small \tx  is \txx beautiful}
%D {small \txx is \tx  beautiful}
%D {small \txx is \txx beautiful}
%D \stopbuffer
%D
%D \typebuffer
%D
%D result in:
%D
%D \startvoorbeeld
%D \startregels
%D \haalbuffer
%D \stopregels
%D \stopvoorbeeld
%D
%D Setting the main size involves the style list and therefore
%D takes a bit more time. Keep in mind that the fontsize is
%D represented by a character or empty.

\beginTEX

\def\dosettextfont#1#2%  Watch the extra test!
  {\unexpanded\setvalue{#1#2}%
     {\csname\textface#1%
        \@EA\ifx\csname\textface#1#2\fontsize\endcsname\relax
          \@EA\ifx\csname\textface#1\c!tf\fontsize\endcsname\relax
            #2%
          \else
            \c!tf\fontsize
          \fi
        \else
          #2\fontsize
        \fi
      \endcsname}}

\endTEX

\beginETEX \ifcsname

\def\dosettextfont#1#2%  Watch the extra test!
  {\unexpanded\setvalue{#1#2}%
     {\csname\textface#1%
        \ifcsname\textface#1#2\fontsize\endcsname
          #2\fontsize
        \else\ifcsname\textface#1\c!tf\fontsize\endcsname
          \c!tf\fontsize
        \else
          #2%
        \fi\fi
      \endcsname}}

\endETEX

\def\settextfont#1%
  {\def\dowithfamily{\dosettextfont{#1}}\processfamilylist}

\def\settextfonts%
  {\rawprocesscommalist[\stylelist]\settextfont}

%D All three sizes come together in the macro:

\def\settypefaces#1#2%
  {\unexpanded\setvalue{#2}%
     {\dosettypeface{#1}{#2}}%
   \unexpanded\setvalue{#2\c!x}%
     {\dosetxtypeface{#2}}%
   \unexpanded\setvalue{#2\c!xx}%
     {\dosetxxtypeface{#2}}}%

%D Earlier in this module we defined some \TEX\ families. Here
%D we introduce the macros that are responsible for setting
%D them. The first argument of the next macro takes the style
%D in its short form (rm, ss, etc). The second argument is the
%D alternative (tf, bf, etc).

%D Before actually assigning the font to a family we activate
%D it. This is needed because loading of fonts is postponed
%D until the first time it's called for. This also forces us to
%D set the text family after we've set the script ones, else
%D the latter one would be in force after executing this macro.

\def\settextfamily#1#2#3% 
  {\scriptscriptfont\csname#3\s!fam\endcsname\scriptfont\csname#3\s!fam\endcsname
   \dosettextfamily{#1}{#2}{#3}\scriptscriptfont\scriptscriptface
   \scriptfont      \csname#3\s!fam\endcsname\textfont  \csname#3\s!fam\endcsname
   \dosettextfamily{#1}{#2}{#3}\scriptfont\scriptface
   \textfont        \csname#3\s!fam\endcsname\textfont  \tffam
   \dosettextfamily{#1}{#2}{#3}\textfont\textface}

\beginTEX

\def\dosettextfamily#1#2#3#4#5%
  {\@EA\ifx\csname#5\c!mm#2\endcsname\relax
     \@EA\ifx\csname#5#1#2\endcsname\relax
       \@EA\ifx\csname#5#1\c!tf\endcsname\relax
        %\debuggerinfo{\m!fonts}{not defined #5#1#2}%
       \else
        %\debuggerinfo{\m!fonts}{#5#1#2 replaced by #5#1\c!tf}%
         \csname#5#1\c!tf\endcsname% activate font
         \@EA#4\csname#3\s!fam\endcsname\csname#5#1\c!tf\endcsname
       \fi
     \else
      %\debuggerinfo{\m!fonts}{defined #5#1#2}%
       \csname#5#1#2\endcsname% activate font
       \@EA#4\csname#3\s!fam\endcsname\csname#5#1#2\endcsname
     \fi
   \else
    %\debuggerinfo{\m!fonts}{#5#1#2 overruled by #5\c!mm#2}%
     \csname#5\c!mm#2\endcsname % activate font
     \@EA#4\csname#3\s!fam\endcsname\csname#5\c!mm#2\endcsname
   \fi}

\endTEX

\beginETEX \ifcsname

\def\dosettextfamily#1#2#3#4#5%
  {\ifcsname#5\c!mm#2\endcsname
    %\debuggerinfo{\m!fonts}{#5#1#2 overruled by #5\c!mm#2}%
     \csname#5\c!mm#2\endcsname % activate font
     \@EA#4\csname#3\s!fam\endcsname\csname#5\c!mm#2\endcsname
   \else\ifcsname#5#1#2\endcsname
    %\debuggerinfo{\m!fonts}{defined #5#1#2}%
     \csname#5#1#2\endcsname% activate font
     \@EA#4\csname#3\s!fam\endcsname\csname#5#1#2\endcsname
   \else\ifcsname#5#1\c!tf\endcsname
    %\debuggerinfo{\m!fonts}{#5#1#2 replaced by #5#1\c!tf}%
     \csname#5#1\c!tf\endcsname% activate font
     \@EA#4\csname#3\s!fam\endcsname\csname#5#1\c!tf\endcsname
   \else
    %\debuggerinfo{\m!fonts}{not defined #5#1#2}%
   \fi\fi\fi}

\endETEX

%D The previous macro lets definitions like
%D
%D \starttypen
%D \definebodyfont[10pt][mm][bf=cmbx10 at 10.25pt]
%D \stoptypen
%D
%D take preference over
%D
%D \starttypen
%D \definebodyfont[10pt][mm][bf=cmbx10 at 10pt]
%D \stoptypen

%D \macros
%D   {definefontstyle}
%D
%D When setting of switching the overall style we can use the
%D short identifier like rm and ss, but when defined we can
%D also use more verbose names like roman or sansserif. Such
%D names are defined by:
%D
%D \starttypen
%D \definefontstyle [serif, rm] [rm]
%D \definefontstyle [sansserif, ss] [ss]
%D \stoptypen

\def\dodefinefontstyle[#1][#2]%
  {\rawdoifinsetelse{#2}{\stylelist}
     {}%\debuggerinfo{\m!fonts}{unknown style #2}}
     {\addtocommalist{#2}\stylelist
      \showmessage{\m!fonts}{8}{#2 (#1)}}%
   \unexpanded\setvalue{#2}{\setfontstyle{#2}{#2}}%
   \setvalue{#2\c!x}%
     {\getvalue{#2}\getvalue{\c!tf\c!x}}%
   \setvalue{#2\c!xx}%
     {\getvalue{#2}\getvalue{\c!tf\c!xx}}%
   \def\docommando##1%
     {\setvalue{\@shortstyle@##1}{#2}%
      \setvalue{\@style@##1}{\getvalue{#2}}%
      }%\unexpanded\setvalue{#2}{\setfontstyle{##1}{#2}}}%
   \processcommalist[#1]\docommando}

\def\definefontstyle%
  {\dodoubleargument\dodefinefontstyle}

%D CHECKEN WAT \type{\fontstyle} HIER DOET

\def\setfontstyle#1#2%  #1:name (roman, romaan)  #2:style (rm)
  {\edef\fontstyle{#1}%
   \def\dowithfamily{\dosetfontstyle{#2}}\processfamilylist
   \unexpanded\def\tx{\tfx}%
   \fam\tffam
   \tf}

\beginTEX

\def\dosetfontstyle#1#2%
  {\@EA\ifx\csname#2\s!fam\endcsname\relax
     \settextfamily{#1}{#2}{\c!nn}%
   \else
     \settextfamily{#1}{#2}{#2}%
   \fi
   \settypefaces{#1}{#2}}

\endTEX

\beginETEX \ifcsname

\def\dosetfontstyle#1#2%
  {\ifcsname#2\s!fam\endcsname
     \settextfamily{#1}{#2}{#2}%
   \else
     \settextfamily{#1}{#2}{\c!nn}%
   \fi
   \settypefaces{#1}{#2}}

\endETEX

%D Setting the math families looks much like setting the texts
%D ones. This time however we use the 12 point font as a
%D default when nothing is defined. This enables us to
%D implement partial schemes. Here we also set the
%D \type{\skewchar}, which takes care of accents in math mode
%D (actually it's the largest accent). The first family needs a
%D bit different treatment because it can be set to the default
%D roman as well as a user defined font.

\def\setmathfamilies%
  {\setskewchar{\textface\c!mm\c!mi}{'177}%
   \setskewchar{\textface\c!mm\c!sy}{'60}%
   \setmathfamily\mrfam\textface\scriptface\scriptscriptface{\c!mm\c!mr}{\c!rm\c!tf}%
   \setmathfamily\mifam\textface\scriptface\scriptscriptface{\c!mm\c!mi}{}%
   \setmathfamily\syfam\textface\scriptface\scriptscriptface{\c!mm\c!sy}{}%
   \setmathfamily\exfam\textface\textface  \textface        {\c!mm\c!ex}{}%
   \setmathfamily\mafam\textface\scriptface\scriptscriptface{\c!mm\c!ma}{}%
   \setmathfamily\mbfam\textface\scriptface\scriptscriptface{\c!mm\c!mb}{}%
   \setmathfamily\mcfam\textface\scriptface\scriptscriptface{\c!mm\c!mc}{}}

%D Optionally skew characters can be set on a per font basis,
%D like:
%D
%D \starttypen
%D \definebodyfont
%D   [12pt] [mm]
%D   [mi=cmmi10,sy=cmsy10,syskewchar='50]
%D \stoptypen
%D
%D When setting the \type{\skewchar} we need to test on the
%D availability first.

\beginTEX

\def\setskewchar#1#2%
  {\@EA\ifx\csname#1\endcsname\relax\else
     \csname#1\endcsname
     \@EA\ifx\csname\??ft#1\s!skewchar\endcsname\relax
       \skewchar\csname#1\endcsname#2\relax
     \else
       \skewchar\csname#1\endcsname\csname\??ft#1\s!skewchar\endcsname\relax
     \fi
   \fi}

\endTEX

\beginETEX \ifcsname

\def\setskewchar#1#2%
  {\ifcsname#1\endcsname
     \csname#1\endcsname
     \ifcsname\??ft#1\s!skewchar\endcsname
       \skewchar\csname#1\endcsname\csname\??ft#1\s!skewchar\endcsname\relax
     \else
       \skewchar\csname#1\endcsname#2\relax
     \fi
   \fi}

\endETEX

%D First we try to set the font at the math specific one (the
%D fifth argment), next we take the alternative the last
%D argument, which of often empty, and finally we default to
%D the 12 point alternative.

\def\setmathfamily#1#2#3#4#5#6% er kunnen veel {} weg 
  {\dosetmathfamily\scriptscriptfont{#4}{#1}{#5}{#6}%
   \dosetmathfamily\scriptfont      {#3}{#1}{#5}{#6}%
   \dosetmathfamily\textfont        {#2}{#1}{#5}{#6}}

\beginTEX

\def\dosetmathfamily#1#2#3#4#5%
  {\@EA\ifx\csname#2#4\endcsname\relax
      \@EA\ifx\csname#2#5\endcsname\relax
         \@EA\ifx\csname\!!twelvepoint#4\endcsname\relax
           #1#3\nullfont
         \else
           \csname\!!twelvepoint#4\endcsname
           #1#3\csname\!!twelvepoint#4\endcsname\relax
         \fi
      \else
        \csname#2#5\endcsname
        #1#3\csname#2#5\endcsname\relax
      \fi
   \else
     \csname#2#4\endcsname
     #1#3\csname#2#4\endcsname\relax
   \fi}

\endTEX

\beginETEX \ifcsname

\def\dosetmathfamily#1#2#3#4#5%
  {\ifcsname#2#4\endcsname
     \csname#2#4\endcsname
     #1#3\csname#2#4\endcsname\relax
   \else\ifcsname#2#5\endcsname
     \csname#2#5\endcsname
     #1#3\csname#2#5\endcsname\relax
   \else\ifcsname\!!twelvepoint#4\endcsname
     \csname\!!twelvepoint#4\endcsname
     #1#3\csname\!!twelvepoint#4\endcsname\relax
   \else
     #1#3\nullfont
   \fi\fi\fi}

\endETEX

%D The previous macros show that it's is not always
%D neccessary to define the whole bunch of fonts, take for
%D instance the sequence:
%D
%D \starttypen
%D \setupbodyfont
%D   [ams]
%D
%D \definebodyfont [24pt] [mm]
%D   [ma=msam10 at 24pt,
%D    mb=msbm10 at 24pt]
%D
%D \switchtobodyfont
%D   [24pt]
%D
%D This is a 24pt $\blacktriangleleft$
%D \stoptypen
%D
%D Here we didn't define the 24 point bodyfont environment, so
%D it's defined automatically. Of course one can always use the
%D \TEX\ primitive \type{\font} to switch to whatever font
%D needed.

%D When asking for a complete font switch, for instance from 10
%D to 12~points, the next macro does the job. First we
%D normalize the size, nect we define the current range of
%D text, script and scriptscript sizes, then we set the text
%D fonts and the math families and finally we activate the
%D default typeface and also set the font specific parameters
%D assigned to \type{\everybodyfont}

\def\docompletefontswitch[#1]%
  {\bodyfontsize=#1\relax
   \dimensiontocount\bodyfontsize\bodyfontpoints
   \edef\bodyfontfactor{\withoutpt\the\bodyfontsize}%
   \normalizebodyfontsize\bodyfontsize\to\normalizedbodyfontsize
   \edef\textface{\getvalue{\??ft\normalizedbodyfontsize\s!text}}%
   \edef\scriptface{\getvalue{\??ft\normalizedbodyfontsize\s!script}}%
   \edef\scriptscriptface{\getvalue{\??ft\normalizedbodyfontsize\s!scriptscript}}%
   \settextfonts
   \setmathfamilies
   \rmtf
   \the\everybodyfont}

%D \macros
%D   {setupbodyfont,switchtobodyfont}
%D
%D The next two macros are user ones. With \type{\setupbodyfont}
%D one can set the document bodyfont size, font family, style
%D and/or options defined in files, for example:
%D
%D \starttypen
%D \setupbodyfont[cmr,ams,12pt,roman]
%D \stoptypen
%D
%D This command affects the document as a whole: text, headers
%D and footers. The second macro however affects only the text:
%D
%D \starttypen
%D \switchtobodyfont[10pt]
%D \stoptypen
%D
%D So we've got:
%D
%D \showsetup{\y!setupbodyfont}
%D \showsetup{\y!switchtobodyfont}
%D
%D Both macros look alike. The second one also has to take
%D all kind of keywords into account.

\definecomplexorsimple\setupbodyfont

\def\simplesetupbodyfont%
  {\restoreglobalbodyfont}

\def\complexsetupbodyfont[#1]%
  {\doifsomething{#1}
     {\dosetfont[#1]%
      \globalbodyfontsize=\localbodyfontsize
      \normalizebodyfontsize\globalbodyfontsize\to\normalizedglobalbodyfontize
      \let\globalfontstyle=\fontstyle
      \the\everybodyfont}}

\unexpanded\def\switchtobodyfont[#1]% 
  {\doifsomething{#1}
     {\doifdefinedelse{\??ft\normalizedbodyfontsize\interfaced{#1}}
        {\doswitchpoints[\getvalue{\??ft\normalizedbodyfontsize\interfaced{#1}}]%
         \doswitchstyle[\fontstyle]}
        {\dosetfont[#1]}%
      \the\everybodyfont}}

%D Because the last macro can appear in arguments or be assigned
%D to parameters, we protect this one for unwanted expansion.

\def\dodosetmathfont#1%
  {\doifdefinedelse{#1\s!fam} % adapted
     {\edef\mffam{\getvalue{#1\s!fam}}}
     {\edef\mffam{\getvalue{\c!nn\s!fam}}}%
   \textfont        \mrfam=\textfont        \mffam
   \scriptfont      \mrfam=\scriptfont      \mffam
   \scriptscriptfont\mrfam=\scriptscriptfont\mffam}

\def\dosetmathfont%
  {\def\rm{\fam0}\dodosetmathfont}

\let\fontalternative=\c!tf

%D Watch the encoding: the first settings are there for
%D upward compatibility reasons, the second one is the new,
%D font synonym related setting.

\def\dosettypeface#1#2%
  {\doifdefinedelse{@\normalizedbodyfontsize#1#2@} % the definition bound one
%     {\edef\characterencoding{\getvalue{@\normalizedbodyfontsize#1#2@}}}
     {\enablecoding[\getvalue{@\normalizedbodyfontsize#1#2@}]}
     {\enablecoding[\s!default]}%
   \edef\fontalternative{#2}%
   \unexpanded\def\tx%
     {\dosetxtypeface{#2\fontsize}}%
   \unexpanded\def\txx%
     {\dosetxxtypeface{#2\fontsize}}%
   \doifdefinedelse{#2\s!fam} % adapted
     {\expandafter\fam\getvalue{#2\s!fam}}
     {\expandafter\fam\getvalue{\c!nn\s!fam}}%
   \getvalue{#1#2}%
   \ifcase\currentxfontsize\or\tx\or\txx\fi
   \doifdefined{\purefontname\font\s!encoding} % the file bound one
     {\enablecoding[\getvalue{\purefontname\font\s!encoding}]}%
   \doifdefinedelse{\purefontname\font\s!mapping} % the file bound one
     {\enablemapping[\getvalue{\purefontname\font\s!mapping}]}%
     {\doifdefined{\purefontname\font\s!encoding} 
        {\enablemapping[\getvalue{\purefontname\font\s!encoding}]}}}

%D The next auxilliary macro is an alternative to \type
%D {\fontname}.

\def\purefontname#1%
  {\expandafter\splitoffpurefontname\fontname#1 \\}

\def\splitoffpurefontname#1 #2\\{#1}

%D Just an experiment: \type{..\sl..\switchstyleonly\tt..}.

\def\switchstyleonly#1%
  {\let\savedfontalternative=\fontalternative
   \chardef\savedescapechar=\escapechar
   \escapechar=-1
   \getvalue{\string#1}%  
   \escapechar=\savedescapechar
   \getvalue{\savedfontalternative}}

% testen 
%
%\def\switchstyleonly#1%
%  {\let\savedfontalternative=\fontalternative
%   \getvalue{\strippedcsname#1}%
%   \getvalue{\savedfontalternative}}

%D \macros
%D   {os}
%D
%D Old style numerals can be typeset with \type{\os} and look
%D like {\os 1234567890} instead of the more common looking
%D 1234567890.

% \unexpanded\def\os%
%   {\getvalue{\normalizedbodyfontsize\c!mm\c!mi}}

\definefont[os][OldStyle sa \currentfontscale]

\definefontsynonym[OldStyle][Serif]

%D \macros
%D   {frak, goth, cal}
%D
%D On behalf of {\frac Tobias Burnus}, we define some more of
%D these: 

\definefont [frak] [Fraktur      sa \currentfontscale]
\definefont [goth] [Gothic       sa \currentfontscale]
\definefont [cal]  [Calligraphic sa \currentfontscale]

\definefontsynonym [Fraktur]      [Serif]
\definefontsynonym [Gothic]       [Serif]
\definefontsynonym [Calligraphic] [Serif]

%D \macros
%D   {fraktur, gothic, calligraphic}
%D
%D For Tobias and friends:

\def\fraktur     #1{\ifmmode\hbox\fi{\frak#1}}
\def\gothic      #1{\ifmmode\hbox\fi{\goth#1}}
\def\calligraphic#1{\ifmmode\hbox\fi{\cal #1}}

%D In \type {font-cmr} we will link these to real file names.

%D \macros
%D   {definebodyfontswitch}
%D
%D \PLAIN\ \TEX\ defines some macro's like \type{\tenpoint}
%D to switch to a specific bodyfontsize. Just for the sake of
%D compatibility we can define them like:
%D
%D \starttypen
%D \definebodyfontswitch [twelvepoint] [12pt]
%D \stoptypen
%D
%D We don't support language specific synonyms here, mainly
%D because \PLAIN\ \TEX\ is english anyway.

\def\dodefinebodyfontswitch[#1][#2]%
  {\def\docommando##1%
     {\setvalue{##1}{\switchtobodyfont[#2]}}%
   \processcommalist[#1]\docommando}

\def\definebodyfontswitch%
  {\dodoubleargument\dodefinebodyfontswitch}

%D \macros
%D   {setsmallbodyfont,setmainbodyfont,setbigbodyfont}
%D
%D When we're typesetting at for instance 10pt, we can call for
%D the \type{small} as well as the \type{big} alternative,
%D related to this main size, using \type{\switchtobodyfont[small]}.
%D The three alternatives can be activated by the next three
%D system calls and are defined by the bodyfontenvironment.

\def\setsmallbodyfont%
  {\doswitchpoints[\getvalue{\??ft\normalizedbodyfontsize\interfaced\v!klein}]%
   \doswitchstyle[\fontstyle]}

\def\setmainbodyfont%
  {\doswitchpoints[\normalizedbodyfontsize]%
   \doswitchstyle[\fontstyle]}

\def\setbigbodyfont%
  {\doswitchpoints[\getvalue{\??ft\normalizedbodyfontsize\v!groot}]%
   \doswitchstyle[\fontstyle]}

%D \macros
%D   {restoreglobalbodyfont}
%D
%D Users can set whatever font available while typesetting text.
%D Pagenumnbers, footers, headers etc. however must be typeset
%D in the main bodyfont and style of the document. Returning to
%D the global state can be done with the next macro:

\def\restoreglobalbodyfont%
  {\let\fontsize=\empty
   \doswitchpoints[\normalizedglobalbodyfontize]%
   \doswitchstyle[\globalfontstyle]%
   \redoconvertfont % just in case a pagebreak occurs
   \tf}

%D This macro has to be called when entering the pagebody
%D handling routine as well as the footnote insert routine.
%D Users can access this feature |<|for instance when one wants
%D to typeset tables and alike in the main bodyfont and style
%D while the running text is temporary set to a smaller one|>|
%D by saying \type{\switchtobodyfont[global]}.

%D \macros
%D   {rasterfont}
%D
%D There are (at the moment) two situations in which we want to
%D have fast access to a particular font. When we are using
%D \TEX\ to typeset rasters, we use small {\rasterfont.}'s
%D (a rather small period indeed), the same as \PICTEX\ uses
%D for drawing purposes.

\def\rasterfont%
  {\getvalue{\!!fivepoint\c!rm\c!tf}}

%D \macros
%D   {infofont}
%D
%D The second situation occurs when we enable the info mode,
%D and put all kind of status information in the margin. We
%D don't want huge switches to the main bodyfont and style, so
%D here too we use a direct method.

\def\infofont%
  {\getvalue{\!!sixpoint\c!tt\c!tf}%
   \the\everybodyfont}

%D \macros
%D   {definealternativestyle}
%D
%D In the main modules we are going to implement lots of
%D parameterized commands and one of these parameters will
%D concern the font to use. To suit consistent use of fonts we
%D here implement a mechanism for defining the keywords that
%D present a particular style or alternative.
%D
%D \starttypen
%D \definealternativestyle [keywords] [\style] [\nostyle]
%D \stoptypen
%D
%D The first command is used in the normal textflow, while the
%D second command takes care of headings and alike. Consider
%D the next two definitions:
%D
%D \starttypen
%D \definealternativestyle [bold] [\bf]  []
%D \definealternativestyle [cap]  [\kap] [\kap]
%D \stoptypen
%D
%D A change \type{\bf} in a heading which is to be set in
%D \type{\tfd} does not look that well, so therefore we leave
%D the second argument of \type{\definealternativestyle} empty.
%D When we capatalize characters using the pseudo small cap
%D command \type{\kap}, we want this to take effect in both
%D text and headings, which is accomplished by assigning both
%D arguments.

\def\dodefinealternativestyle[#1][#2][#3]%
  {\def\docommando##1%
     {\doifundefined{##1}
        {\setvalue{##1}{\groupedcommand{#2}{}}}%
      \setvalue{\@letter@##1}{#2}%
      \setvalue{\@noletter@##1}{#3}}%
   \processcommalist[#1]\docommando}

\def\definealternativestyle%
  {\dotripleempty\dodefinealternativestyle}

\def\definestyle{\definealternativestyle}

%D This command also defines the keyword as command. This means
%D that the example definition of \type{bold} we gave before,
%D results in a command \type{\bold} which can be used as:
%D
%D \startbuffer
%D He's a \bold{bold} man with a {\bold head}.
%D \stopbuffer
%D
%D \typebuffer
%D
%D or
%D
%D \startvoorbeeld
%D \definealternativestyle[bold][\bf][]\haalbuffer
%D \stopvoorbeeld
%D
%D Such definitions are of course unwanted for \type{\kap}
%D because this would result in an endless recursive call.
%D Therefore we check on the existance of both the command and
%D the substitution. The latter is needed because for instance
%D \type{\type} is an entirely diferent command. That command
%D handles verbatim, while the style command would just switch
%D to teletype font. This is just an example of a tricky
%D naming coincidence.

%D \macros
%D   {doconvertfont,noconvertfont,
%D    dontconvertfont,redoconvertfont}
%D
%D After having defined such keywords, we can call for them by
%D using
%D
%D \starttypen
%D \doconvertfont{keyword}{text}
%D \stoptypen
%D
%D We deliberately pass an argument. This enables us to
%D assign converters that handle one agrument, like
%D \type{\kap}.
%D
%D By default the first specification is used to set the style,
%D exept when we say \type{\dontconvertfont}, after which the
%D second specification is used. We can also directly call for
%D \type{\noconvertfont}. In nested calls, we can restore the
%D conversion by saying \type{\redoconvertfont}.

\unexpanded\def\dodoconvertfont#1#2%
  {\doifdefinedelse{\@letter@#1}
     {\doifelsenothing{#1}
        {\let\next=\empty}
        {\def\next{\getvalue{\@letter@#1}}}}
     {\doifdefinedelse{#1}
        {\def\next{\getvalue{#1}}}
        {\def\next{#1}}}%
   \next{#2}}

\let\doconvertfont=\dodoconvertfont

\def\noconvertfont#1#2%
  {\doifdefinedelse{\@noletter@#1}
     {\doifelsenothing{#1}
        {\let\next=\empty}
        {\def\next{\getvalue{\@noletter@#1}}}}
     {\def\next{#1}}%
   \next{#2}}

\unexpanded\def\dontconvertfont%
  {\let\doconvertfont=\noconvertfont}

\unexpanded\def\redoconvertfont%
  {\let\doconvertfont=\dodoconvertfont}

%D These commands are not grouped! Grouping is most probably
%D done by the calling macro's and would lead to unnecessary
%D overhead.

%D \macros
%D  {em,emphasistypeface,emphasisboldface}
%D
%D The next macro started as a copy of Donald Arseneau's
%D \type{\em} (\TUGNEWS\ Vol.~3, no.~1, 1994). His
%D implementation was a bit more sophisticated version of the
%D standard \LATEX\ one. We furter enhanced the macro, so now
%D it also adapts itself to boldface mode. Because we favor
%D {\sl slanted} type over {\it italic}, we made the emphasis
%D adaptable, for instance:
%D
%D \starttypen
%D \def\emphasistypeface {\it}
%D \def\emphasisboldface {\bi}
%D \stoptypen
%D
%D But we prefer:

\def\emphasistypeface {\sl}
\def\emphasisboldface {\bs}

%D or even better: 

\def\emphasistypeface%
  {\doifelsevalue{\??ft\normalizedbodyfontsize\c!em}{\v!schuin}{\sl}
     {\doifvalue{\??ft\normalizedbodyfontsize\c!em}{\v!italic}{\it}}}

\def\emphasisboldface%
  {\doifelsevalue{\??ft\normalizedbodyfontsize\c!em}{\v!schuin}{\bs}
     {\doifvalue{\??ft\normalizedbodyfontsize\c!em}{\v!italic}{\bi}}}

%D To be set with the default body font environment: \type 
%D {em} being \type {slanted} or \type {italic}. 

\newconditional\emneeded

\unexpanded\def\em%
  {\relax
   \ifdim\fontdimen1\font>\!!zeropoint\relax
     \settrue\emneeded
   \else
     \setfalse\emneeded
   \fi
   \setemphasisboldface % new 
   \ifnum\fam=\itfam
     \def\emphasistypeface{\it}\tf
   \else\ifnum\fam=\slfam
     \def\emphasistypeface{\sl}\tf
   \else\ifnum\fam=\bffam
     \emphasisboldface
   \else\ifnum\fam=\bsfam
     \def\emphasisboldface{\bs}\bf
   \else\ifnum\fam=\bifam
     \def\emphasisboldface{\bi}\bf
   \else
     \emphasistypeface
   \fi\fi\fi\fi\fi
   \ifconditional\emneeded\relax
   \else
     \expandafter\aftergroup
   \fi
   \emphasiscorrection}

%D The next feature was not present in previous versions. It 
%D takes are of \type {\em \bf ...} sitiations.

\def\setemphasisboldface%
  {\let\normalbf\bf
   \let\setemphasisboldface\relax
   \def\bf%
     {\relax
      \ifnum\fam=\itfam
        \bi
      \else\ifnum\fam=\slfam
        \bs
      \else
        \normalbf
      \fi\fi
      \let\bf\normalbf}}

%D Donald's (adapted) macros take the next character into
%D account when placing italic correction. As a bonus we also
%D look for something that looks like a dash, in which case we
%D don't correct.

\def\emphasiscorrection%
  {\ifhmode
     \expandafter\emphasislook
   \fi}

\def\emphasislook%
  {\begingroup
   \futurelet\next\emphasistest}

\def\emphasistest%
  {\ifcat\noexpand\next,%
     \setbox\scratchbox=\hbox{\next}%
     \ifdim\ht\scratchbox<.3ex
       \let\doemphasiscorrection\endgroup
     \fi
   \fi
   \doemphasiscorrection}

\def\doemphasiscorrection%
  {\scratchskip=\lastskip
   \ifdim\scratchskip=\!!zeropoint\relax
     \/\relax
   \else
     \unskip\/\hskip\scratchskip
   \fi
   \endgroup}

%D We end with some examples which show the behavior when
%D some punctuation is MET. We also show how the mechanism
%D adapts itself to bold, italic and slanted typing.
%D
%D \startbuffer
%D test {test}test       \par
%D test {\em test}test   \par
%D test {\em test}--test \par
%D
%D test {test}, test     \par
%D test {\em test}, test \par
%D
%D test {\em test {\em test {\em test} test} test} test \par
%D test {\bf test {\em test {\em test} test} test} test \par
%D test {\sl test {\em test {\em test} test} test} test \par
%D test {\it test {\em test {\em test} test} test} test \par
%D \stopbuffer
%D
%D \typebuffer
%D
%D We get:
%D
%D \startvoorbeeld
%D \startopelkaar
%D \haalbuffer
%D \stopopelkaar
%D \stopvoorbeeld

%D \macros
%D   {setfont}
%D
%D Every now and then we want to define a font directly, for
%D instance when we typeset title pages. The next macro saves
%D some typing:

\def\setfont% geen \dosetfont mogelijk
  {\def\next{\nextfont\stelinterliniein}%
   \afterassignment\next\font\nextfont=}

%D One can call this macro as:
%D
%D \starttypen
%D \setfont cmr10 at 60pt
%D \stoptypen
%D
%D After which the font is active and the baselines and
%D struts are set.

%D \macros
%D   {showbodyfont}
%D
%D One can call for a rather simple overview of a bodyfont and the
%D relations between its alternative fonts.
%D
%D \showsetup{\y!showbodyfont}
%D
%D The current bodyfont (here we omitted the argument) looks like:
%D
%D \showbodyfont
%D
%D The implementation is rather straightforward in using
%D \type{\halign}.

\def\doshowbodyfont[#1]%
  {\startbaselinecorrection
   \vbox
     {\def\doreadfontdefinitionfile##1% geen test op geladen 
        {\makeshortfilename[\f!fontprefix\truefontname{##1}]%
         \startreadingfile
         \readsysfile{\shortfilename}{}{}%
         \stopreadingfile}%
      \def\bigstrut##1##2% 
        {\hbox{\vrule
           \!!height ##1\ht\strutbox
           \!!depth  ##2\dp\strutbox
           \!!width  \!!zeropoint}}
      \doifelsenothing{#1}
        {\def\title{\the\korpsgrootte}}
        {\switchtobodyfont[#1]\def\title{#1}}
      \tabskip\!!zeropoint
      \parindent\!!zeropoint
      \def\next##1##2##3%
        {&&##1&&##2\tf##3&&##2\sc##3%
         &&##2\sl##3&&##2\it##3&&##2\bf##3&&##2\bs##3&&##2\bi##3%
         &&##2\tfx##3&&##2\tfxx##3%
         &&##2\tfa##3&&##2\tfb##3&&##2\tfc##3&&##2\tfd##3&\cr}%
      \setlocalhsize
      \halign to \localhsize
        {\bigstrut{1.5}{2}##&\vrule##
         \tabskip=\!!zeropoint \!!plus 1fill
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&##\vrule
         \tabskip=\!!zeropoint\cr
         \noalign{\hrule}
         &\multispan{29}{\vrule\hfil\tttf\strut[\title]\hfil\vrule}\cr
         \noalign{\hrule}\next{}{\tt\string}{}
         \noalign{\hrule}\next{\tt\string\rm}{\rm}{Ag}
         \noalign{\hrule}\next{\tt\string\ss}{\ss}{Ag}
         \noalign{\hrule}\next{\tt\string\tt}{\tt}{Ag}
         \noalign{\hrule}}}
   \stopbaselinecorrection}

\def\showbodyfont%
  {\dosingleempty\doshowbodyfont}

%D \macros
%D   {showbodyfontenvironment}
%D
%D The current bodyfontenvironment is:
%D
%D \showbodyfontenvironment
%D
%D This overview is generated using:
%D
%D \showsetup{\y!showbodyfontenvironment}

\def\showbodyfontenvironment%
  {\dosingleempty\doshowbodyfontenvironment}

\def\doshowbodyfontenvironment[#1]%
  {\startbaselinecorrection
   \vbox
     {\tabskip\!!zeropoint
      \parindent\!!zeropoint
      \doifelsenothing{#1}
        {\def\title{\the\korpsgrootte}}
        {\switchtobodyfont[#1]\def\title{#1}}
      \def\next##1%
        {&&\getvalue{\??ft##1\s!text}%                
         &&\getvalue{\??ft##1\s!script}%              
         &&\getvalue{\??ft##1\s!scriptscript}%        
         &&\getvalue{\??ft##1\c!x}%                  
         &&\getvalue{\??ft##1\c!xx}%                  
         &&\getvalue{\??ft##1\interfaced{\v!klein}}%
         &&\getvalue{\??ft##1\interfaced{\v!groot}}&\cr
         \noalign{\hrule}}
      \setlocalhsize
      \halign to \localhsize
        {##&\vrule##\strut
         \tabskip=\!!zeropoint \!!plus 1fill
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##&\hfil##\hfil&\vrule##
         &\hfil##\hfil&##\vrule
         \tabskip=\!!zeropoint\cr
         \noalign{\hrule}
         &\multispan{15}{\vrule\hfil\tttf\strut[\title]\hfil}\vrule\cr
         \noalign{\hrule}
         &&\bf\s!text&&\bf\s!script&&\bf\s!scriptscript
         &&\bf\c!x&&\bf\c!xx&&\bf\v!klein&&\bf\v!groot&\cr
         \noalign{\hrule}
         \@EA\globalprocesscommalist\@EA[\bodyfontenvironmentlist]\next}}
   \stopbaselinecorrection}

%D \macros
%D   {getglyph}
%D
%D Individual glyphs can be accessed by using
%D
%D \starttypen
%D \getglyph{fontname}{character}
%D \stoptypen
%D
%D This macro is used in for instance the symbol modules and 
%D as one can see, it does obey the small and even smaller 
%D sizes. 

% \def\getglyph#1#2%
%   {{\ifcase\currentxfontsize\or
%       \bodyfontsize=\getvalue{\??ft\normalizedbodyfontsize\c!x}% 
%     \else
%       \bodyfontsize=\getvalue{\??ft\normalizedbodyfontsize\c!xx}% 
%     \fi
%     \font\temp=\truefontname{#1} at \bodyfontsize \temp#2\relax}}

\def\getglyph#1#2%
  {{\definefont[\s!dummy][#1 sa \currentfontscale]\dummy#2}}

%D Fonts can only be used when loaded. In \CONTEXT\ we
%D postpone the loading of fonts, even when we load \PLAIN.
%D This means that we have to redefine one of the \PLAIN\
%D macros. Let's tell that to the user first:

\writestatus{loading}{Postponed Plain TeX Font Definitions}

%D \macros
%D   {bordermatrix}
%D
%D In \PLAIN\ \TEX\ the width of a parenthesis is stored in
%D the \DIMENSION\ \type{\p@renwd}. This value is derived from
%D the width of \type{\tenrm B}, so let's take care of it now:

\let\normalbordermatrix=\bordermatrix

\def\bordermatrix%
  {\bgroup
   \setbox0=\hbox{\getvalue{\textface\c!mm\c!ex}B}%
   \global\p@renwd=\wd0\relax
   \egroup
   \normalbordermatrix}

%D Because we want to be as \PLAIN\ compatible as possible, we
%D make most of \PLAIN's font mechanisme available to the
%D \CONTEXT\ user.

\def\setplainfonts#1#2%
  {\setvalue  {ten#1}{\getvalue{\!!tenpoint  #2}}%
   \setvalue{seven#1}{\getvalue{\!!sevenpoint#2}}%
   \setvalue {five#1}{\getvalue{\!!fivepoint #2}}}

\setplainfonts {\c!rm} {\c!rm\c!tf}
\setplainfonts {\c!bf} {\c!rm\c!bf}
\setplainfonts {\c!sl} {\c!rm\c!sl}
\setplainfonts {\c!it} {\c!rm\c!it}
\setplainfonts {\c!tt} {\c!rm\c!tt}
\setplainfonts {\c!sy} {\c!mm\c!sy}
\setplainfonts {\c!ex} {\c!mm\c!ex}
\setplainfonts {\c!i}  {\c!mm\c!mi}

\let\setplainfonts=\undefined

%D \macros
%D   {ss, SS, sz}
%D
%D We are going to redefine \type{\ss} but for those wo still
%D want to have access to the german \SS, we save it's value in
%D \type{\SS}. Ok, I should have used \type{\sf} insead of
%D \type{\ss} in the first place.

\ifx\undefined\SS \let\SS=\ss \fi
\ifx\undefined\sz \let\sz=\ss \fi

%D \macros
%D   {xi}
%D
%D We are going to redefine \type{\xi}, but fortunately this
%D is a math mode character, so we can just say:

\let\normalxi=\xi

%D \macros
%D   {smashaccent}
%D
%D When we let \TEX\ put an accent on top of a character, such
%D composed characters can get more height that height of a
%D standard \type{\strut}. The next macro takes care of such
%D unwanted compositions.
%D
%D We need to reach over the number that specifies the accent,
%D and in doing so we use \type{\scratchcounter} as a placeholder
%D because it accepts 8 bit numbers in octal, decimal or
%D hexadecimal format. Next we set the height of the accented
%D character to the natural height of the character.

\def\dodosmashaccent#1%
  {\bgroup
   \setbox0=\hbox{#1}%
   \setbox2=\hbox{\normalaccent\scratchcounter#1}%
   \ht2=\ht0\box2
   \egroup
   \nobreak}

\def\dosmashaccent%
  {\afterassignment\dodosmashaccent\expandafter\scratchcounter}

\def\smashaccent%
  {\dontleavehmode
   \let\accent=\dosmashaccent}

%D For instance we can say:
%D
%D \starttypen
%D \smashaccent\"Uberhaupt
%D \stoptypen
%D
%D But normally one will use it as a prefix in definitions. 
%D The difference is in the height: 
%D
%D \leavevmode\ruledhbox
%D   {\ruledhbox{\smashaccent\"Uberhaupt}\quad
%D    oder\quad
%D    \ruledhbox{\"Uberhaupt}} 

%D \macros
%D   {moveaccent}
%D
%D Exact positioning of accents cns be realized by saying:
%D
%D \starttypen
%D \moveaccent{-.1ex}\"uberhaupt
%D \stoptypen
%D
%D Again, this one will mostly used as a prefix in definitions.
%D Here the difference is in the position:
%D
%D \leavevmode\ruledhbox
%D   {\ruledhbox{\moveaccent{-.1ex}\"Uberhaupt}\quad
%D    oder\quad
%D    \ruledhbox{\"Uberhaupt}} 

\def\dodomoveaccent#1%
  {\bgroup
   \dimen0=\fontdimen5\font
   \dimen2=\dimen0
   \advance\dimen2 by -\accentdisplacement
   \fontdimen5\font=\dimen2
   \normalaccent\scratchcounter#1\relax
   \fontdimen5\font=\dimen0
   \egroup}

\def\domoveaccent%
  {\afterassignment\dodomoveaccent\expandafter\scratchcounter}

\def\moveaccent#1%
  {\dontleavehmode
   \def\accentdisplacement{#1}%
   \let\accent=\domoveaccent}

%D Personally I think that using \TEX\ is complicated by the
%D way fonts are handled. Apart from the many encodings, we
%D also deal with different naming schemes. Confronted with
%D this problem, I decided to change the definitions into:
%D
%D \starttypen
%D \definebodyfont [12pt] [rm] [tf=Times-Roman at 12pt]
%D \stoptypen
%D
%D combined with for instance:
%D
%D \starttypen
%D \definefontsynonym [Times-Roman] [tir]
%D \stoptypen
%D
%D Then Taco came up with the suggestion to automate this
%D process by loading the fontmap file as distributed with the
%D \DVIPS\ and \PDFTEX\ program. Therefore, we now have:

\def\loadfontmappingfile#1#2#3% file yes no
  {\pushendofline
   \chardef\@@savedtabcatcode=\the\catcode`\^^I
   \def\dodocommando##1 ##2 ##3 ##4\end%
     {\doifnot{##1}{*}
        {%\writestatus{\m!systems}{font ##2 mapped into ##1}%
         \definefontsynonym[##2][##1]}}%
   \def\docommando%
     {\expandafter\dodocommando\fileline * * * * \end}%
   \doprocessfile\scratchread{#1.map}\docommando
   \catcode`\^^I=\@@savedtabcatcode
   \popendofline
   \iffileprocessed#2\else#3\fi}

%D Now we're up to some definitions. 

\definebodyfontenvironment
  [\s!default]
  [        \s!text=1.0,
         \s!script=0.7,
   \s!scriptscript=0.5,
              \c!a=1.200,
              \c!b=1.440,
              \c!c=1.728,
              \c!d=2.074,
              \c!x=0.8,
             \c!xx=0.6,
          \c!groot=1.2,
          \c!klein=0.8,
     \c!interlinie=,
             \c!em=\v!schuin]

\definebodyfontenvironment
  [20.7pt]
  [        \s!text=20.7pt,
         \s!script=\!!fourteenpointfour,
   \s!scriptscript=\!!twelvepoint, 
              \c!x=17.3pt,
             \c!xx=\!!fourteenpointfour,
          \c!groot=20.7pt,    % !!!!
          \c!klein=17.3pt]

\definebodyfontenvironment
  [17.3pt]
  [        \s!text=17.3pt,
         \s!script=\!!twelvepoint, 
   \s!scriptscript=\!!tenpoint,
              \c!x=\!!fourteenpointfour,
             \c!xx=\!!twelvepoint, 
          \c!groot=20.7pt,
          \c!klein=\!!fourteenpointfour]

\definebodyfontenvironment
  [\!!fourteenpointfour]
  [        \s!text=\!!fourteenpointfour,
         \s!script=\!!elevenpoint,
   \s!scriptscript=\!!ninepoint,
              \c!x=\!!twelvepoint,
             \c!xx=\!!tenpoint,
          \c!groot=\!!fourteenpointfour,
          \c!klein=\!!twelvepoint]

\definebodyfontenvironment
  [\!!twelvepoint]
  [        \s!text=\!!twelvepoint,
         \s!script=\!!ninepoint,
   \s!scriptscript=\!!sevenpoint,
              \c!x=\!!tenpoint,
             \c!xx=\!!eightpoint,
          \c!groot=\!!fourteenpointfour,
          \c!klein=\!!tenpoint]

\definebodyfontenvironment
  [\!!elevenpoint]
  [        \s!text=\!!elevenpoint,
         \s!script=\!!eightpoint,
   \s!scriptscript=\!!sixpoint,
              \c!x=\!!ninepoint,
             \c!xx=\!!sevenpoint,
          \c!groot=\!!twelvepoint,
          \c!klein=\!!ninepoint]

\definebodyfontenvironment
  [\!!tenpoint]
  [        \s!text=\!!tenpoint,
         \s!script=\!!sevenpoint,
   \s!scriptscript=\!!fivepoint,
              \c!x=\!!eightpoint,
             \c!xx=\!!sixpoint,
          \c!groot=\!!twelvepoint,
          \c!klein=\!!eightpoint]

\definebodyfontenvironment
  [\!!ninepoint]
  [        \s!text=\!!ninepoint,
         \s!script=\!!sevenpoint,
   \s!scriptscript=\!!fivepoint,
              \c!x=\!!sevenpoint,
             \c!xx=\!!fivepoint,
          \c!groot=\!!elevenpoint,
          \c!klein=\!!sevenpoint]

\definebodyfontenvironment
  [\!!eightpoint]
  [        \s!text=\!!eightpoint,
         \s!script=\!!sixpoint,
   \s!scriptscript=\!!fivepoint,
              \c!x=\!!sixpoint,
             \c!xx=\!!fivepoint,
          \c!groot=\!!tenpoint,
          \c!klein=\!!sixpoint]

\definebodyfontenvironment
  [\!!sevenpoint]
  [        \s!text=\!!sevenpoint,
         \s!script=\!!sixpoint,
   \s!scriptscript=\!!fivepoint,
              \c!x=\!!sixpoint,
             \c!xx=\!!fivepoint,
          \c!groot=\!!ninepoint,
          \c!klein=\!!fivepoint]

\definebodyfontenvironment
  [\!!sixpoint]
  [        \s!text=\!!sixpoint,
         \s!script=\!!fivepoint,
   \s!scriptscript=\!!fivepoint,
              \c!x=\!!fivepoint,
             \c!xx=\!!fivepoint,
          \c!groot=\!!eightpoint,
          \c!klein=\!!fivepoint]

\definebodyfontenvironment
  [\!!fivepoint]
  [        \s!text=\!!fivepoint,
         \s!script=\!!fivepoint,
   \s!scriptscript=\!!fivepoint,
              \c!x=\!!fivepoint,
             \c!xx=\!!fivepoint,
          \c!groot=\!!sevenpoint,
          \c!klein=\!!fivepoint]

\definebodyfontenvironment
  [\!!fourpoint]
  [        \s!text=\!!fourpoint,
         \s!script=\!!fourpoint,
   \s!scriptscript=\!!fourpoint,
              \c!x=\!!fourpoint,
             \c!xx=\!!fourpoint,
          \c!groot=\!!sixpoint,
          \c!klein=\!!fourpoint]

\definebodyfontswitch [fourteenpointfour] [\!!fourteenpointfour]
\definebodyfontswitch [twelvepoint]       [\!!twelvepoint]
\definebodyfontswitch [elevenpoint]       [\!!elevenpoint]
\definebodyfontswitch [tenpoint]          [\!!tenpoint]
\definebodyfontswitch [ninepoint]         [\!!ninepoint]
\definebodyfontswitch [eightpoint]        [\!!eightpoint]
\definebodyfontswitch [sevenpoint]        [\!!sevenpoint]
\definebodyfontswitch [sixpoint]          [\!!sixpoint]
\definebodyfontswitch [fivepoint]         [\!!fivepoint]
\definebodyfontswitch [fourpoint]         [\!!fourpoint]

\definebodyfontswitch [xii]  [\!!twelvepoint]
\definebodyfontswitch [xi]   [\!!elevenpoint]
\definebodyfontswitch [x]    [\!!tenpoint]
\definebodyfontswitch [ix]   [\!!ninepoint]
\definebodyfontswitch [viii] [\!!eightpoint]
\definebodyfontswitch [vii]  [\!!sevenpoint]
\definebodyfontswitch [vi]   [\!!sixpoint]

%D So far. 
 
\definefontstyle [\c!rm,\v!roman,\v!serif,\v!regular]    [\c!rm]
\definefontstyle [\c!ss,\v!sansserif,\v!sans,\v!support] [\c!ss]    
\definefontstyle [\c!tt,\v!teletype,\v!type,\v!mono]     [\c!tt]
\definefontstyle [\c!hw,\v!handwritten]                  [\c!hw]
\definefontstyle [\c!cg,\v!calligraphic]                 [\c!cg]

\definealternativestyle [\v!mediaeval]                        [\os]  []
\definealternativestyle [\v!normaal]                          [\tf]  []
\definealternativestyle [\v!vet]                              [\bf]  []
\definealternativestyle [\v!type]                             [\tt]  []
\definealternativestyle [\v!schuin]                           [\sl]  []
\definealternativestyle [\v!italic]                           [\it]  []
\definealternativestyle [\v!vetschuin,\v!schuinvet]           [\bs]  []
\definealternativestyle [\v!vetitalic,\v!italicvet]           [\bi]  []
\definealternativestyle [\v!klein,\v!kleinnormaal]            [\tfx] []
\definealternativestyle [\v!kleinvet]                         [\bfx] []
\definealternativestyle [\v!kleintype]                        [\ttx] []
\definealternativestyle [\v!kleinschuin]                      [\slx] []
\definealternativestyle [\v!kleinvetschuin,\v!kleinschuinvet] [\bsx] []
\definealternativestyle [\v!kleinvetitalic,\v!kleinitalicvet] [\bix] []

%D We treat {\sc Small Caps} and \kap {Pseudo Caps} a bit 
%D different. We also provide an \WOORD {uppercase} style. 

\definealternativestyle [\v!kap,\v!kapitaal] [\normalkap] [\normalkap]
\definealternativestyle [\v!smallcaps]       [\sc]        [\sc]
\definealternativestyle [\v!WOORD]           [\WORD]      [\WORD]

%D \macros 
%D   {fontstylesuffix}
%D
%D The next macro is used to map non latin fontnames on 
%D fonts. See \type {font-uni} for an example of its use. 

\def\fontstylesuffix%
  {\ifnum\fam=\tffam     \s!Regular \else 
   \ifnum\fam=\bffam        \s!Bold \else
   \ifnum\fam=\slfam     \s!Slanted \else
   \ifnum\fam=\itfam      \s!Italic \else
   \ifnum\fam=\bsfam \s!BoldSlanted \else
   \ifnum\fam=\bifam  \s!BoldItalic \else
                         \s!Regular \fi\fi\fi\fi\fi\fi}%

%D We still have to take care of \type{\xi}, so:

\def\xi{\ifmmode\normalxi\else\elevenpoint\fi}

%D By default we load the Computer Modern Roman fonts (but 
%D not yet at this moment) and activate the 12pt roman 
%D bodyfont. Sans serif and teletype are also available and 
%D can be called for by \type{\ss} and \type{\tt}. 

\setupbodyfont [unk, fil, rm]

\protect

\endinput

%D Some unused left||overs: 
%D 
%D \starttypen
%D \def\doiffontpresentelse#1#2#3%
%D   {\bgroup
%D    \batchmode\font\dummy=\truefontname{#1}\errorstopmode
%D    \edef\lastfontname{\fontname\dummy}%
%D    \ifx\lastfontname\nullfontname\egroup#3\else\egroup#2\fi}
%D 
%D \def\abortiffontnotfound#1%
%D   {\doiffontpresentelse{#1}{}{\showmessage{\m!fonts}{10}{\truefontname{#1}}\endinput}}
%D \stoptypen
