%D \module
%D   [       file=spec-fdf,
%D        version=1998.05.18,
%D          title=\CONTEXT\ \PDF\ Macros,
%D       subtitle=Adobe \PDF/\FDF\ version 2.1,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

%D Initialization of fields is tricky. If a field has no
%D value, it is kind of not there. If ResetForm is used, the
%D default is assigned, but pushbuttons are spoiled. Adding a
%D \type {/MK} dictionary helps, but gives ugly down
%D appearances (displaced with background). What a mess.
%D Also, in order to get at least something, the \type {/AS}
%D key should be provided.

% to do : /IF << /SW /N >> == no scaling / clipping of widget

\unprotect

%D \macros
%D   {setPDFdestination}
%D
%D \PDF\ destinations should obey the specifications laid down
%D in the \PDF\ reference manual. The next macro strips illegal
%D characters from the destination name.
%D
%D The \ACROBAT\ programs are not bug free. By setting the next
%D switches, we will at least try to prevent problems.

\newif\ifovercomePDFbugs  \overcomePDFbugsfalse % dest sort problem / 3-
\newif\ifovercomePDFspace \overcomePDFspacetrue % dest sort problem / 3-
\newif\ifovercomePDFpage  \overcomePDFpagetrue  % pdf  spec change  / 5+

\chardef\safePDFcode=`-

\def\setPDFdestination#1%
  {\bgroup
   \obeylccodes
   \lccode`\/\safePDFcode \lccode`\#\safePDFcode
   \lccode`\<\safePDFcode \lccode`\>\safePDFcode
   \lccode`\[\safePDFcode \lccode`\]\safePDFcode
   \lccode`\(\safePDFcode \lccode`\)\safePDFcode
   \ifovercomePDFspace
     \lccode`\ \safePDFcode
   \fi
   \ifovercomePDFbugs
     \xdef\PDFdestination{'#1'}%
   \else
     \xdef\PDFdestination{#1}%
   \fi
   % nicer \xdef\PDFdestination{\ifovercomePDFbugs'\fi#1\ifovercomePDFbugs'\fi}%
   \lowercase\@EA{\@EA\xdef\@EA\PDFdestination\@EA{\PDFdestination}}%
   \egroup}

%D This is much faster since we don't have to set the full
%D range of lc-codes; about 5 sec on a 1000mhz PIII for
%D 20K named destinations "x(x) x"). Of course when you use
%D page destinations, the saving is nil.

% \beginETEX \scantokens
%
% \doifnotmode{atpragma}{\let\next\setPDFdestination} % experimental
%
% \bgroup
%
% \catcode`\/=\@@active \catcode`\#=\@@active
% \catcode`\<=\@@active \catcode`\>=\@@active
% \catcode`\[=\@@active \catcode`\]=\@@active
% \catcode`\(=\@@active \catcode`\)=\@@active
%
% \gdef\PDFrepchar{-}
%
% \gdef\setPDFdcharacters
%   {\catcode`\/=\@@active \let/\PDFrepchar
%    \catcode`\#=\@@active \let#\PDFrepchar
%    \catcode`\<=\@@active \let<\PDFrepchar
%    \catcode`\>=\@@active \let>\PDFrepchar
%    \catcode`\[=\@@active \let[\PDFrepchar
%    \catcode`\]=\@@active \let]\PDFrepchar
%    \catcode`\(=\@@active \let(\PDFrepchar
%    \catcode`\)=\@@active \let)\PDFrepchar}
%
% \egroup
%
% \def\setPDFdestination#1% expansion is needed, otherwise embedded
%   {\bgroup              % macros will not expand under the new
%    \setPDFdcharacters   % catcode regime
%    \ifovercomePDFspace
%      \catcode32=\@@ignore
%    \fi
%    \xdef\PDFdestination{\ifovercomePDFbugs'\fi#1\ifovercomePDFbugs'\fi}%
%    \scantokens\@EA{\@EA\xdef\@EA\PDFdestination\@EA{\PDFdestination}}%
%    \egroup}
%
% \doifnotmode{atpragma}{\let\setPDFdestination\next} % experimental
%
% \endETEX

%D \macros
%D   {sanitizePDFstring}
%D
%D This macro at least tries to convert a arbitrary string
%D into a sequence of characters valid for \PDF\ bookmarks and
%D alike. It's a slow one, that uses \type{\lccode}'s to
%D change the glyph as well as converts sensisitve ones into a
%D \PDF\ command sequence, so \type{(} becomes \type{\(}.  In
%D fact we translate the string to lowercase inactive and non
%D special characters, limit their number and finaly convert
%D some of the characters to save ones.

%\beginTEX

\chardef\maxPDFstringsize=60

\def\sanitizePDFstring#1\to#2%
  {\bgroup
   \obeylccodes
   \lccode`( \plusone \lccode`) \plusone
   \lccode`< \plusone \lccode`> \plusone
   \lccode`[ \plusone \lccode`] \plusone
   \lccode`\\\plusone \lccode`/ \plusone
   \lowercase{\convertargument#1\to\ascii}%
   % by integrating the split in the loop below
   % \splitofftokens\maxPDFstringsize\from\ascii\to\ascii
   % we diminish the processing time considerably
   \scratchcounter\maxPDFstringsize
   \def\docommando##1%
     {\ifcase\scratchcounter\else
        \advance\scratchcounter \minusone
        \ifcase\lccode`##1\relax
          \xdef#2{#2.}% let's show that something is missing
        \or
          \xdef#2{#2\expandafter\string\csname##1\endcsname}%
        \else
          \xdef#2{#2##1}%
        \fi
      \fi}%
   %\global\let#2=\empty
   % or to permit #2 to be \ascii too:
   \global\@EA\let\@EA#2\@EA\empty
   \@EA\handletokens\ascii\with\docommando
   \egroup}

%\endTEX
%
% \beginETEX \scantokens
%
% \doifnotmode{atpragma}{\let\next\sanitizePDFstring} % experimental
%
% \bgroup
%
% \catcode`\.=\@@escape
%
% .catcode`./=.@@active
% .catcode`.<=.@@active .catcode`.>=.@@active
% .catcode`.[=.@@active .catcode`.]=.@@active
% .catcode`.(=.@@active .catcode`.)=.@@active
%
% .gdef.setPDFscharacters%
%   {.catcode`.\=.@@other
%    .catcode`./=.@@active .def/{.noexpand./}%
%    .catcode`.<=.@@active .def<{.noexpand.<}%
%    .catcode`.>=.@@active .def>{.noexpand.>}%
%    .catcode`.[=.@@active .def[{.noexpand.[}%
%    .catcode`.]=.@@active .def]{.noexpand.]}%
%    .catcode`.(=.@@active .def({.noexpand.(}%
%    .catcode`.)=.@@active .def){.noexpand.)}}
%
% .gdef.sanitizePDFstring#1.to#2%
%   {.bgroup
%    .setPDFscharacters
%    .catcode`=.@@escape
%    .edef.next{.strippedcsname#2}%
%    .scantokens{setxvalue{next}{#1}}%
%    .egroup}
%
% .egroup
%
% \doifnotmode{atpragma}{\let\sanitizePDFstring\next} % experimental
%
% \endETEX

%D \macros
%D   {doPDFdestination,
%D    doPDFaction,
%D    doPDFannotation,
%D    doPDFannotationobject,
%D    doPDFdictionaryobject,
%D    doPDFarrayobject,
%D    doPDFaddtocatalog,
%D    doPDFaddtoinfo,
%D    doPDFpageattribute,
%D    doPDFpageresource,
%D    doPDFpagesattribute,
%D    doPDFbookmark,
%D    defaultobjectreference,
%D    doPDFgetobjectreference}
%D
%D This module deals with \PDF\ support, including fill||in
%D forms. Before we present the largely unreadable bunch of
%D macros, we introduce the here||not||defined low level
%D interface macros. These must be provided by the special
%D drivers \type{pdf} (\ACROBAT) and \type{tpd} (\PDFTEX).
%D
%D \starttypen
%D \doPDFdestination        name #1
%D \doPDFaction             width #1 height #2 action #3
%D \doPDFannotation         width #1 height #2 data #3
%D \doPDFannotationobject   class #1 name #2 width #3 height #4 data #5
%D \doPDFdictionaryobject   class #1 name #2 data #3
%D \doPDFarrayobject        class #1 name #2 data #3
%D \doPDFaddtocatalog       #1
%D \doPDFaddtoinfo          #1
%D \doPDFpageattribute      #1
%D \doPDFpageresource       #1
%D \doPDFpagesattribute     #1
%D \doPDFbookmark           level #1 n #2 text #3 page #4 open #5
%D
%D \defaultobjectreference  #1#2   % class name
%D \doPDFgetobjectreference #1#2#3 % class name \PDFobjectreference
%D \stoptypen
%D
%D The keywords reflect their use. For the moment we stick to
%D keywords, because that way at we get an indication of what
%D we're doing.

\startspecials[fdf]

%D Due to the fact that \PDFTEX\ has a different concept of
%D page attributes, we need:

\let\doPDFresetpageattributes\relax
\let\doPDFresetpageresources \relax

\appendtoksonce
  \doPDFresetpageattributes
  \doPDFresetpageresources
\to \everyaftershipout

\ifx\PDFcode\undefined
  \ifx\pdfliteral\undefined
    \def\PDFcode#1{\message{[ignored pdfliteral: #1]}}
  \else
    \let\PDFcode\pdfliteral
  \fi
\fi

%D For special (\METAPOST) effects, we need to build
%D resource dictionaries. Here is the framework.

\let\docuPDFextgstates\empty
%let\pagePDFextgstates\empty

\def\checkPDFextgstates
  {\ifx\docuPDFextgstates\empty \else
     \ifnum\realpageno=\lastpage\relax
       \doPDFdictionaryobject class FDF name docuextgstates data
         {\docuPDFextgstates}%
     \fi
     \doPDFgetobjectreference{FDF}{docuextgstates}\PDFobjectreference
     \doPDFpageresource{/ExtGState \PDFobjectreference}%
   \fi}

\appendtoksonce
  \checkPDFextgstates
\to \everyshipout

\def\appendtoPDFdocumentextgstates#1%
  {\xdef\docuPDFextgstates{\docuPDFextgstates\space#1}}

%D Another special mechanism (needed for color separation):

\let\docuPDFcolorspaces\empty

\def\checkPDFcolorspaces
  {\ifx\docuPDFcolorspaces\empty \else
     \ifnum\realpageno=\lastpage\relax
       \doPDFdictionaryobject class FDF name colorspaces data
         {\docuPDFcolorspaces}%
     \fi
     \doPDFgetobjectreference{FDF}{colorspaces}\PDFobjectreference
     \doPDFpageresource{/ColorSpace \PDFobjectreference}%
   \fi}

\appendtoksonce
  \checkPDFcolorspaces
\to \everyshipout

\def\appendtoPDFdocumentcolorspaces#1%
  {\xdef\docuPDFcolorspaces{\docuPDFcolorspaces\space#1}}

%D \macros
%D   {doPDFsetupscreen,doPDFsetupidentity}
%D
%D Opposite to \DVI\ drivers, \PDF\ ones must know which what
%D page dimensions they are dealing. We also use the
%D opportunity to launch full screen (1) or show bookmarks (2).

\let\currentPDFpagemode   \empty % document catalog
\let\currentPDFviewerprefs\empty % document catalog

\let\currentPDFcropbox    \empty % page attributes
\let\currentPDFbleedbox   \empty % page attributes
\let\currentPDFartbox     \empty % page attributes
\let\currentPDFtrimbox    \empty % page attributes

\def\doPDFsetupscreen#1#2#3#4#5#6% watch the extra argument
  {\bgroup
%   \!!widtha#4%
%   \advance\!!widtha#2%
%   \!!heighta-#5%
%   \!!heightb#1% extra argument
%   \advance\!!heightb -#3%
%   \advance\!!heighta \!!heightb
%   % sometimes whole values give better results
%   % \PointsToWholeBigPoints{#2}\left
%   % \PointsToWholeBigPoints\!!heighta\bottom
%   % \PointsToWholeBigPoints\!!widtha \width
%   % \PointsToWholeBigPoints\!!heightb\height
%   % but since pdf/x does not round when checking if
%   % the boxes fit inside the media box ...
%   \PointsToBigPoints{#2}\left
%   \PointsToBigPoints\!!heighta\bottom
%   \PointsToBigPoints\!!widtha \width
%   \PointsToBigPoints\!!heightb\height
%   \xdef\currentPDFcropboxspec
%     {[\left\space\bottom\space\width\space\height]}%
%   \global\let\currentPDFtrimboxspec\currentPDFcropboxspec
%
%   \xdef\currentPDFpagemode
%     {/PageMode \ifcase#6 
%        /UseNone\or/FullScreen\or/UseOutlines\else/UseNone\fi}%
%
   \xdef\currentPDFpagemode
     {\ifnum#6=4 
        /PageLayout /TwoColumnRight
      \else
        /PageMode \ifcase#6  
        /UseNone\or/FullScreen\or/UseOutlines\else/UseNone\fi
      \fi}%
   \xdef\currentPDFviewerprefs % space after #6 needed, else \relax
     {\ifcase#6 \or\or\else /ViewerPreferences << /FitWindow true >>\fi}%
   \egroup}

\appendtoksonce % hack to prevent duplicates
  \ifcase\realfolio \or % only at page one
    \doPDFaddtocatalog{\currentPDFpagemode\currentPDFviewerprefs}%
    \doPDFaddtoinfo{/Trapped /False}%
  \fi
\to \everyshipout

\def\doPDFsetupwhateverbox#1#2#3#4#5#6% watch the extra arguments
  {\bgroup
   \!!widtha#5%
   \advance\!!widtha#3%
   \!!heighta-#6%
   \!!heightb#2% extra argument
   \advance\!!heightb -#4%
   \advance\!!heighta \!!heightb
   % sometimes whole values give better results
   % \PointsToWholeBigPoints{#3}\left
   % \PointsToWholeBigPoints\!!heighta\bottom
   % \PointsToWholeBigPoints\!!widtha \width
   % \PointsToWholeBigPoints\!!heightb\height
   % but since pdf/x does not round when checking if
   % the boxes fit inside the media box ...
   \PointsToBigPoints{#3}\left
   \PointsToBigPoints\!!heighta\bottom
   \PointsToBigPoints\!!widtha \width
   \PointsToBigPoints\!!heightb\height
   \xdef#1{[\left\space\bottom\space\width\space\height]}%
   \egroup}

\def\doPDFsetupartbox  {\doPDFsetupwhateverbox\currentPDFartbox  }
\def\doPDFsetupcropbox {\doPDFsetupwhateverbox\currentPDFcropbox }
\def\doPDFsetupbleedbox{\doPDFsetupwhateverbox\currentPDFbleedbox}
\def\doPDFsetuptrimbox {\doPDFsetupwhateverbox\currentPDFtrimbox }

\gdef\currentPDFtrimbox{\currentPDFcropbox} % default, needed for pdf/x

\def\flushPDFwhateverbox#1#2%
  {\doifsomething{#1}{\doPDFpageattribute{/#2Box #1}}}

\appendtoksonce
  \flushPDFwhateverbox\currentPDFartbox  {Art}%
  \flushPDFwhateverbox\currentPDFcropbox {Crop}%
  \flushPDFwhateverbox\currentPDFbleedbox{Bleed}%
  \flushPDFwhateverbox\currentPDFtrimbox {Trim}%
\to \everyshipout

\def\doPDFsetupidentity#1#2#3#4#5#6%
  {\bgroup
   \enablePDFdocencoding
   \expanded{\doPDFaddtoinfo
     {/Title (#1)
      /Subject (#2)
      /Author (#3)
      /Creator (#4)
      /ModDate (#5)
      /ID (\jobname.#5) % needed for pdf/x
      /Keywords (#6)}}%
   \egroup}

%D \macros
%D   {doPDFsetupopenaction,doPDFsetupcloseaction,
%D    doPDFsetupopenpageaction,doPDFsetupclosepageaction}
%D
%D Setting the open and close actions is kind of fuzzy
%D because action chains are derived from the reference
%D mechanism.

\let\lastPDFaction\empty

%D We can safe a couple of references by moving this code
%D to the specific drivers.
%D
%D The following code used to work okay, but as with any
%D update of Acrobat Viewers, upward compatibility was
%D just a dream.

\def\doPDFsetupopenaction
  {\doPDFaddtocatalog{/OpenAction <<\lastPDFaction>>}}

\def\doPDFsetupcloseaction
  {\doPDFaddtocatalog{/CloseAction <<\lastPDFaction>>}}

%D So, starting with version~5 viewers, when the open actions
%D started yto give problems, for testing purposes we
%D decided use indirect actions.

%\def\doPDFsetupopenaction%
%  {\doPDFdictionaryobject class FDF name local:openaction data \lastPDFaction
%   \doPDFgetobjectreference{FDF}{local:openaction}\PDFobjectreference
%   \doPDFaddtocatalog{/OpenAction \PDFobjectreference}}
%
%\def\doPDFsetupcloseaction%
%  {\doPDFdictionaryobject class FDF name local:closeaction data \lastPDFaction
%   \doPDFgetobjectreference{FDF}{local:closeaction}\PDFobjectreference
%   \doPDFaddtocatalog{/CloseAction \PDFobjectreference}}

\let\PDFopenpageaction \empty
\let\PDFclosepageaction\empty

\def\doPDFsetupopenpageaction%
  {\global\let\PDFopenpageaction\lastPDFaction}

\def\doPDFsetupclosepageaction
  {\global\let\PDFclosepageaction\lastPDFaction}

\def\checkPDFpageactions
  {\iflocation % important since direct -)
     \donefalse
     \ifx\PDFopenpageaction \empty\!!doneafalse\else\donetrue\!!doneatrue\fi
     \ifx\PDFclosepageaction\empty\!!donebfalse\else\donetrue\!!donebtrue\fi
     \ifdone
       \doPDFpageattribute
         {/AA <<\if!!donea/O <<\PDFopenpageaction >> \fi
                \if!!doneb/C <<\PDFclosepageaction>> \fi>>}%
     \fi
     \global\let\PDFopenpageaction \empty
     \global\let\PDFclosepageaction\empty
   \fi}

\appendtoksonce
  \checkPDFpageactions
\to \everyshipout

%D \macros
%D   {doPDFstartthisislocation}
%D
%D Next we define the macros that deal with hyperreferencing,
%D graphic inclusion and general document features. These are
%D the olderst ones. I won't comment much because one needs
%D knowledge of \PDF\ itself, and explaning \PDF\ is beyond
%D this documentation.

\def\doPDFstartthisislocation#1%
  {\bgroup
   \setPDFdestination{#1}%
  %\doifsomething{\PDFdestination}
  %  {\doPDFdestination name {\PDFdestination}}%
   \ifx\PDFdestination\empty \else
     \doPDFdestination name {\PDFdestination}%
   \fi
   \egroup}

%D \macros
%D   {doPDFstartgotolocation,
%D    doPDFstartgotorealpage,
%D    doPDFstartgotoJS}
%D
%D The goto macros use the switch \type{\ifsecondaryreference}
%D to determine if actions should be linked.

\def\locationfilesuffix{pdf} 

% \def\preparePDFlocationfile#1#2%
%   {\setreferencefilename#1\to#2%
%    \expanded{\doifnotinstring{.\locationfilesuffix}{#2}}
%      {\edef#2{#2.\locationfilesuffix}}}
%
% \def\preparePDFlocationfile#1\to#2%
%   {\setreferencefilename#1\to#2%
%    \expanded{\doifnotinstring{.pdf}{#2}}{\edef#2{#2.pdf}}}

\def\doPDFstartgotolocation#1#2#3#4#5#6%
  {\bgroup
   \doifelsenothing{#3}
     {\setPDFdestination{#5}%
      \doifelsenothing\PDFdestination
        {\let\action\empty}
        {\doifelsenothing{#4}
           {\let\PDFfile\empty}
           {\expanded{\beforesplitstring#4}\at.\to\PDFfile
            \doifparentfileelse\PDFfile % {#4}
              {\let\PDFfile\empty}
             %{\setreferencefilename#4.\locationfilesuffix\to\PDFfile
              {\@EA\setreferencefilename\PDFfile.\locationfilesuffix\to\PDFfile
               \edef\PDFfile
                 {R /F (\PDFfile)\ifgotonewwindow\space/NewWindow true \fi}}}%
         \edef\action%
           {/S /GoTo\PDFfile\space /D (\PDFdestination)}}}
     {\doifelsenothing{#4}
        {\let\PDFfile\empty
         \let\PDFdestination\empty}
        {\setreferencefilename/#4\to\PDFfile
         \setPDFdestination{#5}%
         \doifsomething\PDFdestination
           {\edef\PDFdestination{\URLhash\PDFdestination}}}%
      \edef\action{/S /URI /URI (#3\PDFfile\PDFdestination)}}%
   \ifx\action\empty\else
     \ifsecondaryreference
       \savesecondaryPDFreference\action
     \else
       \getsecondaryPDFreferences
       \doPDFaction
         width #1 height #2
         action {\action \secondaryPDFreferences}%
     \fi
   \fi
   \egroup}

\def\PDFgotonewwindow{\ifgotonewwindow\space/NewWindow true \fi}

\def\doPDFstartgotorealpage#1#2#3#4#5% watch the R append trick
  {\bgroup
   \doifelsenothing{#3}% #1 = url 
     {\scratchcounter0#5\relax
      \ifnum\scratchcounter>0
        \advance\scratchcounter \minusone % pdf starts numbering at zero
        \doifelsenothing{#4}
          {\let\PDFfile\empty}
          {\expanded{\beforesplitstring#4}\at.\to\PDFfile
           \doifparentfileelse\PDFfile % {#4}
             {\let\PDFfile\empty}
            %{\setreferencefilename#4.\locationfilesuffix\to\PDFfile
             {\@EA\setreferencefilename\PDFfile.\locationfilesuffix\to\PDFfile
              \edef\PDFfile{R /F (\PDFfile)\PDFgotonewwindow}}}%
        \ifx\PDFfile\empty
          \ifovercomePDFpage % a named page ref
            \edef\PDFdestination{(page:\the\scratchcounter)}%
          \else % beware: optimizers remove this one
            \edef\PDFdestination{[\the\scratchcounter\space\PDFpageviewwrd]}%
          \fi
        \else % across files it's a page number
          \edef\PDFdestination{[\the\scratchcounter\space\PDFpageviewwrd]}%
        \fi
        \edef\action{/S /GoTo\PDFfile\space /D \PDFdestination}%
      \else
        \let\action\empty
      \fi}
     {\doifelsenothing{#4}
        {\let\PDFfile\empty}
        {\setreferencefilename/#4\to\PDFfile}%
      \edef\action{/S /URI /URI (#3\PDFfile)}}%
   \ifx\action\empty\else
     \ifsecondaryreference
       \savesecondaryPDFreference\action
     \else
       \getsecondaryPDFreferences
       \doPDFaction
         width #1 height #2
         action {\action \secondaryPDFreferences}%
     \fi
   \fi
   \egroup}

\let\lastfakedPDFpage\!!zerocount

\def\fakePDFpagedestination % as in pdf, we start numbering at zero
  {\iflocation \ifovercomePDFpage \ifarrangingpages \else
     \ifnum\lastfakedPDFpage<\realpageno
       \bgroup
         \xdef\lastfakedPDFpage{\realfolio}%
         \advance\realpageno \minusone % is \expanded needed ?
         \expanded{\doPDFdestination name {page:\realfolio}}%
       \egroup
     \fi
   \fi \fi \fi}

\appendtoksonce
  \fakePDFpagedestination
\to \everyshipout

\def\doPDFstartgotoJS#1#2#3%
  {\bgroup
   \doPSsanitizeJScode#3\to\sanitizedJScode
   \edef\action%
     {/S /JavaScript /JS (\sanitizedJScode)}%
   \ifsecondaryreference
     \savesecondaryPDFreference\action
   \else
     \getsecondaryPDFreferences
     \doPDFaction
       width #1 height #2
       action {\action \secondaryPDFreferences}%
   \fi
   \egroup}

%D \macros
%D   {doPDFstartexecutecommand}
%D
%D At the cost of much auxiliary placeholders, we can pretty
%D fast convert the command asked for. This is how the \PDF\
%D code looks like.

\def\PDFmoviecode#1#2#3%
  {/Movie
   /T (\ifcase#1movie \else sound \fi\ifx\argumentA\empty#2\else\argumentA\fi)
   /Operation /\ifcase#3Play\or Stop\or Pause\or Resume\fi\space}

\def\PDFexecutestartmovie  {\PDFmoviecode0\currentmovie0}
\def\PDFexecutestopmovie   {\PDFmoviecode0\currentmovie1}
\def\PDFexecutepausemovie  {\PDFmoviecode0\currentmovie2}
\def\PDFexecuteresumemovie {\PDFmoviecode0\currentmovie3}

\def\PDFexecutestartsound  {\PDFmoviecode1\currentsound0}
\def\PDFexecutestopsound   {\PDFmoviecode1\currentsound1}
\def\PDFexecutepausesound  {\PDFmoviecode1\currentsound2}
\def\PDFexecuteresumesound {\PDFmoviecode1\currentsound3}

\def\PDFformcode#1%
  {\doFDFiffieldset{#1}{/Field [\doFDFgetfieldset{#1}]}}

% bit 3 = html
% bit 6 = xml
% bit 4 = get

\ifx\PDFsubmitfiller\undefined \let\PDFsubmitfiller\empty \fi 

\chardef\PDFformmethod=1 % 0=GET 1=POST

\def\PDFformflag#1#2{\ifcase\PDFformmethod#1\else#2\fi}

\def\PDFexecuteimportform  {/Named /N /AcroForm:ImportFDF}
\def\PDFexecuteexportform  {/Named /N /AcroForm:ExportFDF}
\def\PDFexecuteresetform   {/ResetForm  \PDFformcode\argumentA}
\def\PDFexecutesubmitform  {/SubmitForm \PDFformcode\argumentB
                            /Flags \ifcase\submitoutputformat\space
                                         \PDFformflag{12} {4} % 0=unknown
                                   \or   \PDFformflag{12} {4} % 1=HTML
                                   \or   \PDFformflag {8} {0} % 2=FDF
                                   \or   \PDFformflag{40}{32} % 3=XML
                                   \else \PDFformflag{12} {4} % ?=unknown
                                   \fi
                            /F (\argumentA)\PDFsubmitfiller} 

% urifill permits url substitution

\def\PDFexecutehide        {/Hide /T (\argumentA) /H true}
\def\PDFexecuteshow        {/Hide /T (\argumentA) /H false}

\def\PDFexecutefirst       {/Named /N /FirstPage}
\def\PDFexecuteprevious    {/Named /N /PrevPage}
\def\PDFexecutenext        {/Named /N /NextPage}
\def\PDFexecutelast        {/Named /N /LastPage}
\def\PDFexecutebackward    {/Named /N /GoBack}
\def\PDFexecuteforward     {/Named /N /GoForward}
\def\PDFexecuteprint       {/Named /N /Print}
\def\PDFexecuteexit        {/Named /N /Quit}
\def\PDFexecuteclose       {/Named /N /Close}
\def\PDFexecutesave        {/Named /N /Save}
\def\PDFexecutesavenamed   {/Named /N /SaveAs}
\def\PDFexecuteopennamed   {/Named /N /Open}
\def\PDFexecutehelp        {/Named /N /HelpUserGuide}
\def\PDFexecuteswap        {/Named /N /FullScreen}
\def\PDFexecutesearch      {/Named /N /Find}
\def\PDFexecutesearchagain {/Named /N /FindAgain}
\def\PDFexecutegotopage    {/Named /N /GoToPage}
\def\PDFexecutequery       {/Named /N /AcroSrch:Query}
\def\PDFexecutequeryagain  {/Named /N /AcroSrch:NextHit}
\def\PDFexecutefitwidth    {/Named /N /FitWidth}
\def\PDFexecutefitheight   {/Named /N /FitHeight}

\def\doPDFstartexecutecommand#1#2#3#4%
  {\doifdefined{PDFexecute#3}
     {\bgroup
      \@EA\dogetcommalistelement\@EA1\@EA\from#4\to\argumentA
      \@EA\dogetcommalistelement\@EA2\@EA\from#4\to\argumentB
      \edef\argument{#4}%
      \edef\action%
        {/S \getvalue{PDFexecute#3}}%
      \ifsecondaryreference
        \savesecondaryPDFreference\action
      \else
        \getsecondaryPDFreferences
        \doPDFaction
          width #1 height #2
          action {\action \secondaryPDFreferences}%
      \fi
      \egroup}}

%D \macros
%D   {doPDFstartrunprogram}
%D
%D Running programs is possible, but is non that portable, and
%D therefore dangerous.

\def\doPDFstartrunprogram#1#2#3#4% new: #3 => #3#4
  {\bgroup
  %\edef\string{#3}%
  %\@EA\beforesplitstring\string\at{ }\to\program
  %\@EA\aftersplitstring \string\at{ }\to\parameters
  %\edef\action%
  %  {/S /Launch /F (\program) /P (\parameters) /D (.)}%
   \edef\action%
     {/S /Launch /F (#3) /P (#4) /D (.)}%
   \ifsecondaryreference
     \savesecondaryPDFreference\action
   \else
     \getsecondaryPDFreferences
     \doPDFaction
       width #1 height #2
       action {\action \secondaryPDFreferences}%
   \fi
   \egroup}

%D \macros
%D   {doPDFstartgotoprofile}
%D
%D Far from perfect, but nevertheless present, is the profile
%D handler. We want to misuse article threads for reder
%D profiles.

\def\doPDFstartgotoprofile#1#2#3% to be done: file
  {\bgroup
   \setPDFdestination{#3}%
   \doifsomething\PDFdestination
     {\edef\action%
        {/S /Thread /D (\PDFdestination)}%
      \ifsecondaryreference
        \savesecondaryPDFreference\action
      \else
        \getsecondaryPDFreferences
        \doPDFaction
          width #1 height #2
          action {\action \secondaryPDFreferences}%
      \fi}%
   \egroup}

%D \macros
%D   {doPDFsetpagetransition}
%D
%D This array holds a reasonable selection of transitions
%D (watch out: \type{replace} is not in this list). Most of
%D the transitions look awful anyway. By the way, \CONTEXT\ is
%D able to select transitions randomly.

\def\pagetransitions
  {{split,in,vertical},{split,in,horizontal},
   {split,out,vertical},{split,out,horizontal},
   {blinds,horizontal},{blinds,vertical},
   {box,in},{box,out},
   {wipe,east},{wipe,west},{wipe,north},{wipe,south},
   dissolve,
   {glitter,east},{glitter,south}}

%D Again, we use macros as placeholders for \PDF\ key||value
%D pairs.

\def\PDFpagesplit    {/S /Split    }
\def\PDFpageblinds   {/S /Blinds   }
\def\PDFpagebox      {/S /Box      }
\def\PDFpagewipe     {/S /Wipe     }
\def\PDFpagedissolve {/S /Dissolve }
\def\PDFpageglitter  {/S /Glitter  }
\def\PDFpagereplace  {/S /R        }

\def\PDFpagehorizontal {/Dm /H  }
\def\PDFpagevertical   {/Dm /V  }
\def\PDFpagein         {/M  /I  }
\def\PDFpageout        {/M  /O  }
\def\PDFpageeast       {/Di   0 }
\def\PDFpagenorth      {/Di  90 }
\def\PDFpagewest       {/Di 180 }
\def\PDFpagesouth      {/Di 270 }

\def\dodoPDFsetpagetransition#1%
  {\doifdefined{PDFpage#1}
     {\edef\PDFpagetransitions{\PDFpagetransitions\getvalue{PDFpage#1}}}}

\def\doPDFsetpagetransition#1#2%
  {\let\PDFpagetransitions\empty
   \processcommalist[#1]\dodoPDFsetpagetransition
   \doPDFpageattribute
    %{\ifnum#2>0 /Dur #2 \fi
     {\ifnum0<0#2 /Dur #2 \fi
      \ifx\PDFpagetransitions\empty\else/Trans <<\PDFpagetransitions>>\fi}}
%      \ifx\PDFpagetransitions\empty\else/Trans <</Type /Trans \PDFpagetransitions>>\fi}}

%D \macros
%D   {doPDFinsertmov}
%D
%D Most of the annotations we use here are of type {\em
%D link}, but here is another one: the {\em movie} annotation.
%D The driver module must implement \type {setcurrentmovie}.

\let\currentmovie\s!unknown

\def\doPDFinsertmov#1#2#3#4#5#6#7#8#9%
  {\bgroup
   \xdef\currentmovie{#2}% label
   \PointsToBigPoints{#7}\width
   \PointsToBigPoints{#8}\height
   \let\pdf@@options\empty
   \let\pdf@@actions\empty
   \donefalse
   \@EA\processallactionsinset\@EA
     [#9]
     [\v!sturing=>\donetrue,
      \v!herhaal=>\edef\pdf@@actions{\pdf@@actions /Mode /Repeat },
      \v!preview=>\edef\pdf@@options{\pdf@@options /Poster true  }]%
   \edef\pdf@@actions{\pdf@@actions /ShowControls \ifdone true\else false\fi}%
   \doPDFannotation width #7 height #8 data
     {/Subtype /Movie
      /T (movie \currentmovie)
      /Movie << /F (#1) /Aspect [\width\space\height] \pdf@@options >>
      /A << \pdf@@actions >>}%
   \egroup}

%D \macros
%D   {doPDFinsertsoundtrack}
%D
%D In \PDF\ sounds can be embedded like movies.

\let\currentsound\s!unknown

\def\doPDFinsertsoundtrack#1#2#3%
  {\bgroup
   \xdef\currentsound{#2}%
   \let\pdf@@actions\empty
   \@EA\processallactionsinset\@EA
     [#3]
     [\v!herhaal=>\edef\pdf@@actions{\pdf@@actions /Mode /Repeat }]%
   \flushatshipout % since it can be buried in a chained box
     {\doPDFannotation width 0pt height 0pt data
        {/Subtype /Movie
         /T (sound \currentsound)
         /Movie <</F (#1)>>%
         \ifx\pdf@@actions\empty\else/A << \pdf@@actions >>\fi}}%
   \egroup}

%D \macros
%D   {doPDFinsertbookmark}
%D
%D Well, here is the dreadfull bookmark, rather useless because
%D only standard encoding is possible, no typography is done,
%D and a maximum of 32~characters is advized.

\def\doPDFinsertbookmark#1#2#3#4#5% level sublevels text page open=1
  {\bgroup
   % todo, unicode
   \sanitizePDFdocencoding#3\to\bookmarktext % uses scratchcounter
   \scratchcounter#4%
   \advance\scratchcounter \minusone
  %\sanitizePDFstring#3\to\bookmarktext
   \doPDFbookmark level #1 n #2 text {\bookmarktext}
      page {\the\scratchcounter} open #5
   \egroup}

%D The next section of this module is dedicated to form
%D support. These macros are complicated by the fact that
%D cloning is possible.

%D \macros
%D   {FDFflag...,FDFplus...}
%D
%D The \type{/FT} key determines the type of field: text,
%D button or choice. The latter two come in several disguises,
%D which are set by flipping bits in the \type{/Ff}. Other bits
%D are used to set states. Personally I hate this bitty way of
%D doing things. The next six bit determine the field sub type:

\def\FDFflagMultiLine          {4096} % 13
\def\FDFflagNoToggleToOff     {16384} % 15
\def\FDFflagRadio             {32768} % 16
\def\FDFflagPushButton        {65536} % 17
\def\FDFflagPopUp            {131072} % 18
\def\FDFflagEdit             {262144} % 19

%D A few more (pdf 1.4) flags, what the spell check one: for
%D obscure reasons for Adobe downward compatibility means
%D enabling features that harm old applications like testing.

\def\FDFflagDoNotSpellCheck {4194304} % 23
\def\FDFflagDoNotScroll     {8388608} % 24

%D The next bits (watch how strange the bits are organized)
%D take care of the states:

\def\FDFflagReadOnly              {1} %  1
\def\FDFflagRequired              {2} %  2
\def\FDFflagNoExport              {4} %  3
\def\FDFflagPassword           {8192} % 14
\def\FDFflagSort             {524288} % 20
\def\FDFflagFileSelect      {1048576} % 21

%D There is a second, again bitset oriented, \type{/F} flag:

\def\FDFplusInvisible             {1} %  1
\def\FDFplusHidden                {2} %  2
\def\FDFplusPrintable             {4} %  3

%D \macros
%D   {setFDFswitches}
%D
%D The non||type bits are mapped onto user||interface
%D swithes, to be used later on:

\def\@@FDFflag{FDFflag}
\def\@@FDFplus{FDFplus}

\letvalue  {\@@FDFflag\v!alleenleesbaar}=\FDFflagReadOnly
\letvalue       {\@@FDFflag\v!verplicht}=\FDFflagRequired
\letvalue       {\@@FDFflag\v!beschermd}=\FDFflagPassword
\letvalue      {\@@FDFflag\v!gesorteerd}=\FDFflagSort
\letvalue {\@@FDFflag\v!nietbeschikbaar}=\FDFflagNoExport
\letvalue    {\@@FDFflag\v!geencontrole}=\FDFflagDoNotSpellCheck
\letvalue            {\@@FDFflag\v!vast}=\FDFflagDoNotScroll
\letvalue            {\@@FDFflag\v!file}=\FDFflagFileSelect

\letvalue       {\@@FDFplus\v!verborgen}=\FDFplusHidden
\letvalue       {\@@FDFplus\v!printbaar}=\FDFplusPrintable

%D A set of switches is collected into the flags we mentioned
%D before by the next macro (we don't handle negations yet,
%D but do take care of redundancy):

\def\FDFflag{0}
\def\FDFplus{0}

\def\setFDFswitches[#1]%
  {\bgroup
   \!!counta\zerocount
   \!!countb\zerocount
   \def\docommando##1%
     {\doifsomething{##1}
        {\advance\!!counta 0\getvalue{\@@FDFflag##1}%
         \setvalue{\@@FDFflag##1}{0}%
         \advance\!!countb 0\getvalue{\@@FDFplus##1}%
         \setvalue{\@@FDFplus##1}{0}}}%
   \processcommacommand[#1]\docommando
   \xdef\FDFflag{\the\!!counta}%
   \xdef\FDFplus{\the\!!countb}%
   \egroup}

%D \macros
%D   {setFDFvalues}
%D
%D Menu items are passed as an array of \type{(string)}'s and
%D the content of this array is build with:

\let\FDFvalues      \empty
\let\FDFfirstvalues \empty
\let\FDFsecondvalues\empty
\let\FDFkidlist     \empty
\let\FDFdefaultindex\!!zerocount
\let\FDFdefaultvalue\empty

\def\setFDFvalues[#1][#2]% #1 = list (item=>value) #2 = default
  {\let\FDFvalues      \empty
   %when radio opt works ok
   %\let\FDFfirstvalues \empty
   %\let\FDFsecondvalues\empty
   %\let\FDFkidlist     \empty
   %\let\FDFdefaultindex\!!zerocount
   %\let\FDFdefaultvalue\empty
   %\scratchcounter\zerocount
   \def\dodocommando##1=>##2=>##3\end
     {%\addtocommalist{##1}\FDFkidlist
      %\edef\FDFfirstvalues{\FDFfirstvalues(##1)}%
      %\doif{##1}{#2}{\edef\FDFdefaultindex{\the\scratchcounter}}%
      %\advance\scratchcounter\plusone
      \doifelsenothing{##2}
        {%\doif{##1}{#2}{\edef\FDFdefaultvalue{##1}}%
         %\edef\FDFsecondvalues{\FDFsecondvalues(##1)}%
         \edef\FDFvalues{\FDFvalues [(##1)(##1)] }}
        {%\doif{##1}{#2}{\edef\FDFdefaultvalue{##2}}%
         %\edef\FDFsecondvalues{\FDFsecondvalues(##2)}%
         \edef\FDFvalues{\FDFvalues [(##2)(##1)] }}}% ! ##1 is shown
   \def\docommando##1%
     {\dodocommando##1=>=>\end}%
   \expanded{\processcommalist[#1]}\docommando}

%D This macro accepts comma separated \type{visual=>result}
%D pairs.

%D \macros
%D   {setFDFalignment}
%D
%D Text and line fields can be entered and showed in three
%D alternative alingments, indicated by a digit:

\def\FDFalign{0}

\def\setFDFalignment[#1]%
  {\processaction
     [#1]
     [ \v!links=>\edef\FDFalign{2},    % raggedleft
      \v!midden=>\edef\FDFalign{1},    % raggedcenter
      \v!rechts=>\edef\FDFalign{0}]}   % raggedright

%D \macros
%D   {setFDFattributes}
%D
%D The weak part of (at least version 2.1 \PDF) is that only
%D default fonts are handled well. Another restriction is that
%D the encoding vector must be the standard \PDF\ document one.
%D Although the \PDF\ reference explictly states that one could
%D use the normal text operators, leading is not yet handled.
%D
%D For the moment the current \CONTEXT\ font is mapped onto
%D one best suitable default font. The color attribute is
%D less problematic and is directly derived from the \CONTEXT\
%D color.

\def\FDFattributes{/Helv 12 Tf 0 g 14.4 TL}

\def\FDFrm  {TiRo} \def\FDFss  {Helv} \def\FDFtt  {Cour}
\def\FDFrmtf{TiRo} \def\FDFsstf{Helv} \def\FDFtttf{Cour}
\def\FDFrmbf{TiBo} \def\FDFssbf{HeBo} \def\FDFttbf{CoBo}
\def\FDFrmit{TiIt} \def\FDFssit{HeOb} \def\FDFttit{CoOb}
\def\FDFrmsl{TiIt} \def\FDFsssl{HeOb} \def\FDFttsl{CoOb}
\def\FDFrmbi{TiBI} \def\FDFssbi{HeBO} \def\FDFttbi{CoBO}
\def\FDFrmbs{TiBI} \def\FDFssbs{HeBO} \def\FDFttbs{CoBO}

\let\FDFusedfonts=\FDFsstf

\def\setFDFattributes[#1,#2,#3,#4]% style, color, backgroundcolor, framecolor
  {\bgroup % nog interlinie: n TL
   \setbox\scratchbox=\hbox
     \bgroup
       \doconvertfont{#1}{}%
       \PointsToBigPoints\bodyfontsize\size % x/xx, so better the actual size
       \doifdefinedelse{FDF\fontstyle\fontalternative}
         {\xdef\FDFattributes{\getvalue{FDF\fontstyle\fontalternative}}}
         {\doifdefinedelse{FDF\fontstyle}
            {\xdef\FDFattributes{\getvalue{FDF\fontstyle}}}
            {\xdef\FDFattributes{\FDFrm}}}%
       \doglobal\addtocommalist\FDFattributes\FDFusedfonts
       \xdef\FDFattributes% move up with "x.y Ts"
         {/\FDFattributes\space\size\space Tf\space\PDFcolor{#2}}%
       \doifelsenothing{#3}
         {\global\let\FDFsurroundings\empty}
         {\xdef\FDFsurroundings{/BG \FDFcolor{#3}}}%
       \doifsomething{#4}
         {\xdef\FDFsurroundings{\FDFsurroundings\space /BC \FDFcolor{#4}}}%
       \ifx\FDFsurroundings\empty \else
         \xdef\FDFsurroundings{/MK << \FDFsurroundings\space>>}%
       \fi
     \egroup
   \egroup}

%D \macros
%D   {setFDFactions}
%D
%D Depending on the type of the field, one can assign
%D \JAVASCRIPT\ code to a mouse event or keystroke. The next
%D preparation macro shows what events are handled.

\let\FDFactions\empty

%\def\setFDFactions[#1,#2,#3,#4,#5,#6,#7,#8]%
%  {\global\let\FDFactions\empty
%   \setFDFaction D#1%  mousedown
%   \setFDFaction U#2%  mouseup
%   \setFDFaction E#3%  enterregion
%   \setFDFaction X#4%  exitregion
%   \setFDFaction K#5%  afterkeystroke
%   \setFDFaction F#6%  formatresult
%   \setFDFaction V#7%  validateresult
%   \setFDFaction C#8%  calculatewhatever
%   \ifx\FDFactions\empty\else
%     \xdef\FDFactions{/AA << \FDFactions >>}% since 1.3 no longer inherited
%   \fi}
%%  \setFDFaction A#2}% mouseup % changed for version 5

\def\setFDFactions[#1,#2,#3,#4,#5,#6,#7,#8,%
  {\global\let\FDFactions\empty
   \setFDFaction D#1%  mousedown
%  \setFDFaction U#2%  mouseup
   \setFDFaction E#3%  enterregion
   \setFDFaction X#4%  exitregion
   \setFDFaction K#5%  afterkeystroke
   \setFDFaction F#6%  formatresult
   \setFDFaction V#7%  validateresult
   \setFDFaction C#8%  calculatewhatever
   \setFDFactionsmore#2,}

\def\setFDFactionsmore#1,#2,#3]%
  {\setFDFaction{Fo}#2%  focusin
   \setFDFaction{Bi}#3%  focusout
   \ifx\FDFactions\empty\else
     \xdef\FDFactions{/AA << \FDFactions >>}% since 1.3 no longer inherited
   \fi
   \setFDFaction A#1}% mouseup

%D The event handler becomes something:
%D
%D \starttypen
%D /AA << /D << /S ... >> ... /C << /S ... >>
%D /A << /S /JavaScript /JS (...) >>
%D \stoptypen

% \def\setFDFaction#1#2%
%   {\bgroup
%    \global\let\sanitizedJScode\empty
%    \def\setFDFaction##1%
%      {\doifreferencefoundelse{##1}
%         {\doifelse{\currentreferencespecial}{JS} % filter non-js
%            {\presetJScode
%               \currentreferenceoperation
%               \currentreferencearguments
%             \doPSsanitizeJScode\JScode\to\JScode
%             \xdef\sanitizedJScode{\sanitizedJScode\space\JScode}}
%            {\illegalreference{##1}}}
%         {\unknownreference{##1}}}%
%    \@EA\processcommalist\@EA[#2]\setFDFaction % one level expansion
%    \ifx\sanitizedJScode\empty \else
%      \xdef\FDFactions%
%        {\FDFactions /#1 << /S /JavaScript /JS (\sanitizedJScode) >> }%
%    \fi
%    \egroup}
%
% acrobat 5 supports other that JS actions too

\def\setFDFaction#1#2%
  {\bgroup
   \def\docommando%
     {\xdef\FDFactions{\FDFactions /#1 << \lastPDFaction >> }}%
   \@EA\handlereferenceactions\@EA{#2}\docommando % one level expansion
   \egroup}

%D \macros
%D   {testFDFactions}
%D
%D This rather confusion prone series of script can be tested
%D with:
%D
%D \starttypen
%D \testFDFactions
%D \stoptypen
%D
%D which simply redefined the previous macro to one that prints
%D a message to the console.

\def\testFDFactions%
  {\def\setFDFaction##1##2%
     {\doPSsanitizeJScode console.show();console.println("executing:##1");
        \to\sanitizedJScode
      \edef\FDFactions%
        {\FDFactions /##1 << /S /JavaScript /JS (\sanitizedJScode) >> }}}

%D \macros
%D   {doFDFregistercalculationset}
%D
%D There is at most one calculation order list, which defines
%D the order in which fields are calculated.

\let\PDFcalculationset\empty

\def\doFDFregistercalculationset#1%
  {\def\PDFcalculationset{#1}}

%D \macros
%D   {registerFDFobject,everylastshipout}
%D
%D Officially one needs to embed some general datastructures
%D that tell the viewer what fields are present in the file, as
%D well as what resources they use. The next mechanism does that
%D job automatically when one registers the field.

\def\flushFDFnames
  {\ifbuildFDFdictionary
     \ifx\FDFcollection\empty\else
       \ifbuildFDFencodingvector
         \doPDFdictionaryobject class FDF name local:encodingvector data
           \FDFencodingvector
       \fi
       \defineFDFfonts
       \doPDFarrayobject class FDF name local:fields data \FDFcollection
       \doPDFgetobjectreference{FDF}{local:fields}\PDFobjectreference
       % The /NeedAppearances is pretty important because
       % otherwise Acrobat 5 blows up on cloned radio widgets
       \doPDFdictionaryobject class FDF name local:acroform data
         {/Fields \PDFobjectreference\space
          /NeedAppearances true
          \doFDFiffieldset\PDFcalculationset{/CO [\doFDFgetfieldset\PDFcalculationset]}
          /DR << /Font << \FDFfonts >> >>
          /DA (/Helv 10 Tf 0 g)}%
       \doPDFgetobjectreference{FDF}{local:acroform}\PDFobjectreference
       \doPDFaddtocatalog
         {/AcroForm \PDFobjectreference}%
       \global\let\FDFcollection\empty
       \global\let\flushFDFnames\relax
     \fi
   \fi}

\let\FDFcollection\empty

\def\registerFDFobject#1%
  {\ifbuildFDFdictionary
     \ifx\flushFDFnames\relax
       \writestatus{FDF}{second run needed for field list (#1)}%
     \fi
     \doPDFgetobjectreference{FDF}{#1}\PDFobjectreference
     \xdef\FDFcollection%
       {\FDFcollection\space\PDFobjectreference}%
   \fi}

\prependtoksonce \flushFDFnames \to \everylastshipout % test \everybye

%D \macros
%D   {defineFDFfonts,
%D    ifbuildFDFdictionary,
%D    ifbuildFDFencodingvector}
%D
%D Another datastruture concerns the fonts used. We only
%D define the fonts we use.

\newif\ifbuildFDFdictionary     \buildFDFdictionarytrue
\newif\ifbuildFDFencodingvector \buildFDFencodingvectortrue

\def\defineFDFfonts%
  {\let\FDFfonts\empty
   \processcommacommand[\FDFusedfonts]\defineFDFfont}

\def\defineFDFfont#1%
  {\ifbuildFDFencodingvector
     \doPDFgetobjectreference{FDF}{local:encodingvector}\PDFobjectreference
   \fi
   \doPDFdictionaryobject class FDF name local:#1 data
     {/Type /Font
      /Subtype /Type1
      /Name /#1
      \ifbuildFDFencodingvector /Encoding \PDFobjectreference\space\fi
      /BaseFont /\getvalue{FDFname#1}}%
   \doPDFgetobjectreference{FDF}{local:#1}\PDFobjectreference
   \edef\FDFfonts{\FDFfonts \space/#1 \PDFobjectreference}}

%D Another list of constants:

\def\FDFnameTiRo {Times-Roman}
\def\FDFnameTiBo {Times-Bold}
\def\FDFnameTiIt {Times-Italic}
\def\FDFnameTiBI {Times-BoldItalic}
\def\FDFnameHelv {Helvetica}
\def\FDFnameHeBo {Helvetica-Bold}
\def\FDFnameHeOb {Helvetica-Oblique}
\def\FDFnameHeBO {Helvetica-BoldOblique}
\def\FDFnameCour {Courier}
\def\FDFnameCoBo {Courier-Bold}
\def\FDFnameCoOb {Courier-Oblique}
\def\FDFnameCoBO {Courier-BoldOblique}

%D And a big one: (should be run time loaded (spec-run or
%D so)).

\def\FDFencodingvector
  {/Type /Encoding
   /Differences
     [ 24 /breve /caron /circumflex /dotaccent /hungarumlaut /ogonek
          /ring /tilde
       39 /quotesingle
       96 /grave
      128 /bullet /dagger /daggerdbl /ellipsis /emdash /endash /florin
          /fraction /guilsinglleft /guilsinglright /minus /perthousand
          /quotedblbase /quotedblleft /quotedblright /quoteleft
          /quoteright /quotesinglbase /trademark /fi /fl /Lslash /OE
          /Scaron /Ydieresis /Zcaron /dotlessi /lslash /oe /scaron
          /zcaron
      164 /currency
      166 /brokenbar
      168 /dieresis /copyright /ordfeminine
      172 /logicalnot /.notdef /registered /macron /degree /plusminus
          /twosuperior /threesuperior /acute /mu
      183 /periodcentered /cedilla /onesuperior /ordmasculine
      188 /onequarter /onehalf /threequarters 192 /Agrave /Aacute
          /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave
          /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex
          /Idieresis /Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde
          /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex
          /Udieresis /Yacute /Thorn /germandbls /agrave /aacute
          /acircumflex /atilde /adieresis /aring /ae /ccedilla /egrave
          /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex
          /idieresis /eth /ntilde /ograve /oacute /ocircumflex /otilde
          /odieresis /divide /oslash /ugrave /uacute /ucircumflex
          /udieresis /yacute /thorn /ydieresis ]}

%D \macros
%D   {currentFDFmode,currentFDFparent,currentFDFkids,currenrFDFroot}
%D
%D There are three more quasi global interfacing variables
%D that need to be set.

\let\currentFDFmode  =\fieldlonermode
\let\currentFDFkids  =\empty
\let\currentFDFparent=\empty
\let\currentFDFroot  =\empty

%D \macros
%D   {dosetfieldstatus}
%D
%D And here comes the special that deals with them.

\definespecial\dosetfieldstatus#1#2#3#4%
  {\chardef\currentFDFmode #1%
   \edef\currentFDFparent {#2}%
   \edef\currentFDFkids   {#3}%
   \edef\currentFDFroot   {#4}}

%D \macros
%D   {dosetuppageview}
%D
%D Because this command will seldom be called, we can permit
%D slow action processing. We need three settings, one for
%D direct \PDF\ inclusion, the other as \PDFTEX\ keyword, an
%D a last one for form. All determine in what way the
%D screen is adapted when going to a destination. Watch the
%D space.

\def\PDFpageviewkey{  fit}
\def\PDFpageviewwrd{ /Fit}
\def\PDFpageview   {/View [\PDFpageviewwrd] }

\def\PDFpagexyzspec{ 0 0 0} % hack, pdftex does handle this

\def\dosetuppageview#1%
  {\processaction
     [#1]
     [\v!passend=>\def\PDFpageviewkey{   fit}%
                  \def\PDFpageviewwrd{  /Fit},
      \v!breedte=>\def\PDFpageviewkey{  fith}%   % watch the v-h
                  \def\PDFpageviewwrd{ /FitH},   % swapping here
       \v!hoogte=>\def\PDFpageviewkey{  fitv}%   % and here and
                  \def\PDFpageviewwrd{ /FitV},   % here too
    \v!standaard=>\def\PDFpageviewkey{   xyz\PDFpagexyzspec}%
                  \def\PDFpageviewwrd{  /XYZ\PDFpagexyzspec},
      \s!unknown=>\def\PDFpageviewkey{   fit}%
                  \def\PDFpageviewwrd{  /Fit}]%
   \edef\PDFpageview{/View [\PDFpageviewwrd]}}

%D \macros
%D   {setFDFkids}
%D
%D Clones as well as radiofields (which themselves can have
%D cloned components) need a list of kids. The next macro
%D builds one.

\def\setFDFkids[#1][#2]% tag commalist
  {\let\FDFkids\empty
   \def\docommando##1%
     {\doPDFgetobjectreference{FDF}{#1##1}\PDFobjectreference
      \edef\FDFkids{\FDFkids\PDFobjectreference\space}}%
   \@EA\processcommalist\@EA[#2]\docommando}

%D \macros
%D   {doFDFpresetlinefield,doFDFpresettextfield,
%D    doFDFpresetchoicefield,doFDFpresetpopupfield,doFDFpresetcombofield,
%D    doFDFpresetpushfield,doFDFpresetcheckfield,
%D    doFDFpresetradiofield,doFDFpresetradiorecord}
%D
%D I would say: read the \PDF\ reference manual first and see
%D what happens here next. Lucky us that they have so much in
%D common.

\def\doFDFpresetlinefield#1#2#3#4#5#6#7#8#9%
  {\bgroup
   \setFDFswitches[#7]%
   \setFDFattributes[#6]%
   \setFDFalignment[#8]%
   \setFDFactions[#9]%
   \expanded{\escapePSstring#4}\to\FDFtext
   \ifcase\currentFDFmode
     \doPDFannotationobject class FDF name #1 width #2 height #3 data
       {/Subtype /Widget /T (#1) /FT /Tx
        /MaxLen \ifcase0#5 1000 \else#5 \fi
       %/DV (#4) /V (#4) % value added
        /DV (\FDFtext) /V (\FDFtext) % value added
        /Ff \FDFflag\space
        /F \FDFplus\space
        /DA (\FDFattributes)
        \FDFsurroundings\space
        /Q \FDFalign\space
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \setFDFkids[kids:][\currentFDFkids]%
     \doPDFdictionaryobject class FDF name #1 data
       {/T (#1) /FT /Tx
        /MaxLen \ifcase0#5 1000 \else#5 \fi
        /Kids [\FDFkids]
       %/DV (#4) /V (#4) % value added
        /DV (\FDFtext) /V (\FDFtext) % value added
        /Ff \FDFflag\space
        /F \FDFplus\space
        /DA (\FDFattributes)
        \FDFsurroundings\space
        /Q \FDFalign\space
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference
        /Ff \FDFflag\space
        /F \FDFplus\space
        /DA (\FDFattributes)
        \FDFsurroundings\space
        /Q \FDFalign\space
        \FDFactions}%
   \or
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference
        /F \FDFplus
        \FDFactions}%
   \fi
   \egroup}

\def\doFDFpresettextfield#1#2#3#4#5#6#7#8#9%
  {\doFDFpresetlinefield{#1}{#2}{#3}{#4}{#5}{#6}{MultiLine,#7}{#8}{#9}}

\def\doFDFpresetchoicefield#1#2#3#4#5#6#7#8%
  {\bgroup
   \setFDFswitches[#6]%
   \setFDFattributes[#5]%
   \setFDFvalues[#7][#4]%
   \setFDFactions[#8]%
   \ifcase\currentFDFmode
     \doPDFannotationobject class FDF name #1 width #2 height #3 data
       {/Subtype /Widget
        /T (#1) /FT /Ch
        /DV (#4) /V (#4)
        /Ff \FDFflag\space
        /F \FDFplus\space
        /DA (\FDFattributes)
        \FDFsurroundings\space
        /Opt [\FDFvalues]
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \setFDFkids[kids:][\currentFDFkids]%
     \doPDFdictionaryobject class FDF name #1 data
       {/T (#1) /FT /Ch
        /Kids [\FDFkids]
        /DV (#4) /V (#4)
        /Ff \FDFflag\space
        /F \FDFplus\space
        /DA (\FDFattributes)
        \FDFsurroundings\space
        /Opt [\FDFvalues]
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference
        /Ff \FDFflag\space
        /F \FDFplus\space
        /DA (\FDFattributes)
        \FDFsurroundings\space
        \FDFactions}%
   \or
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference
        /F \FDFplus
        \FDFactions}%
   \fi
   \egroup}

\def\doFDFpresetpopupfield#1#2#3#4#5#6#7#8%
  {\doFDFpresetchoicefield{#1}{#2}{#3}{#4}{#5}{PopUp,#6}{#7}{#8}}

\def\doFDFpresetcombofield#1#2#3#4#5#6#7#8%
  {\doFDFpresetchoicefield{#1}{#2}{#3}{#4}{#5}{PopUp,Edit,#6}{#7}{#8}}

\newif\ifFDFvalues

\def\doFDFpresetpushcheckfield#1#2#3#4#5#6#7#8% in acro<5 (\FDFdefault)
  {\bgroup                                    % in acro>5 /\FDFdefault
   \ifcase#8\relax\FDFvaluesfalse\else\FDFvaluestrue\fi
   \setFDFswitches[#5]%
   \setFDFactions[#7]%
   \doifelse{#4}{1}
     {\def\FDFdefault{On}}
     {\def\FDFdefault{Off}}%
   \ifcase\currentFDFmode
     \doFDFappearance{On}{#6}{#8}%
     \doPDFannotationobject class FDF name #1 width #2 height #3 data
       {/Subtype /Widget /T (#1) /FT /Btn
        \ifFDFvalues
          /DV /\FDFdefault\space
          /V  /\FDFdefault\space
          /AS /\FDFdefault\space
        \fi
        /Ff \FDFflag\space
        /F \FDFplus\space
        \FDFappearance\space
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \setFDFkids[kids:][\currentFDFkids]%
     \doPDFdictionaryobject class FDF name #1 data
       {/T (#1) /FT /Btn
        /Kids [\FDFkids]
        \ifFDFvalues
          /DV /\FDFdefault\space
          /V  /\FDFdefault\space
          /AS /\FDFdefault\space
        \fi
        /Ff \FDFflag\space
        /F \FDFplus\space
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \doFDFappearance{On}{#6}{#8}%
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference\space
        \ifFDFvalues
          /DV /\FDFdefault\space
          /V  /\FDFdefault\space
          /AS /\FDFdefault\space
        \fi
        /Ff \FDFflag\space
        /F \FDFplus\space
        \FDFappearance\space
        \FDFactions}%
   \or
     \doFDFappearance{On}{#6}{#8}%
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference\space
        /F \FDFplus\space
        \ifFDFvalues
          /DV /\FDFdefault\space
          /V  /\FDFdefault\space
          /AS /\FDFdefault\space
        \fi
        \FDFappearance
        \FDFactions}%
   \fi
   \egroup}

\def\doFDFpresetpushfield#1#2#3#4#5#6#7%
  {\doFDFpresetpushcheckfield{#1}{#2}{#3}{#4}{PushButton,#5}{#6}{#7}{0}}

\def\doFDFpresetcheckfield#1#2#3#4#5#6#7%
  {\doFDFpresetpushcheckfield{#1}{#2}{#3}{#4}{#5}{#6}{#7}{1}}

\def\doFDFpresetradiofield#1#2#3#4#5#6#7#8%
  {\bgroup
   \FDFvaluestrue
   \setFDFswitches[#5]%
   \setFDFactions[#8]%
   \doifelsenothing{#4}
     {\def\FDFdefault{Off}}
     {\def\FDFdefault{#4}}%
\@EA\aftersplitstring\FDFdefault\at=>\to\FDFdefaultvalue
\ifx\FDFdefaultvalue\empty\else\let\FDFdefault\FDFdefaultvalue\fi
   \ifcase\currentFDFmode
     \doFDFappearance{#1}{#7}{1}%
     \doPDFgetobjectreference{FDF}{#6}\PDFobjectreference
     \doPDFannotationobject class FDF name #1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference\space
        /F \FDFplus\space
        /AS /\FDFdefault\space
        \FDFappearance\space
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     \setFDFkids[kids:][\currentFDFkids]%
     \doPDFgetobjectreference{FDF}{#6}\PDFobjectreference
     \doPDFdictionaryobject class FDF name #1 data
       {/Parent \PDFobjectreference\space
        /Kids [\FDFkids]
        /F \FDFplus\space
        \FDFactions}%
     \registerFDFobject{#1}%
   \or
     %\doFDFappearance{#1}{#7}{1}%
     \doFDFappearance{\currentFDFparent}{#7}{1}%
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue % nb
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference\space
        /AS /\FDFdefault\space
        /F \FDFplus\space
        \FDFappearance\space
        \FDFactions}%
   \or
     %\doFDFappearance{#1}{#7}{1}%
     \doFDFappearance{\currentFDFparent}{#7}{1}%
     \doPDFgetobjectreference{FDF}\currentFDFparent\PDFobjectreference
     \global\objectreferencingtrue
     \doPDFannotationobject class FDF name kids:#1 width #2 height #3 data
       {/Subtype /Widget
        /Parent \PDFobjectreference\space
        /AS /\FDFdefault\space
        /F \FDFplus\space
        \FDFappearance\space
        \FDFactions}%
   \fi
   \egroup}

%D \macros
%D   {setFDFstrings}
%D
%D This one creates a string array.

%\def\setFDFstrings[#1]%
%  {\let\FDFstrings\empty
%   \def\docommando##1{\edef\FDFstrings{\FDFstrings(##1)}}%
%   \processcommacommand[#1]\docommando}

\def\doFDFpresetradiorecord#1#2#3#4#5%
  {\bgroup
   \setFDFswitches[Radio,NoToggleToOff,#3]%
   \setFDFkids[#4][]%
%\setFDFvalues[#4][#2]%
%\expanded{\setFDFkids[][\FDFkidlist]}%
   \setFDFactions[#5]%
   \doPDFdictionaryobject class FDF name #1 data
     {/Subtype /Widget /FT /Btn /T (#1) /Rect [0 0 0 0]
      % used to be this
      % /V (#2)
      % then this
      % /DV (#2)
      % since this bomded in 5
      % /V (#2)
      % and now finally this works
      /H /N
% /opt is buggy in 5.05, only works once, sigh
%\ifx\FDFfirstvalues\FDFsecondvalues
  /V /#2
%\else
%  /V /\FDFdefaultindex\space
%  /Opt [\FDFsecondvalues]
%\fi
      /Ff \FDFflag\space
      /F \FDFplus\space
      /Kids [\FDFkids]
      \FDFactions}%
   \egroup}

%D At the cost of some more references, we can save bytes,
%D by sharing appearance dictionaries. This code needs more
%D documentation. Surprise:

\def\dodoFDFappearance#1#2%
  {\ifx#2\empty\else
     \dogetcommacommandelement1\from#2\to\commalistelement
     \ifx\commalistelement\empty\else
       \doPDFgetobjectreference{SYM}\commalistelement\PDFobjectreference
       \edef\N{\ifFDFvalues\N /#1 \fi\PDFobjectreference\space}%
     \fi
     \dogetcommacommandelement2\from#2\to\commalistelement
     \ifx\commalistelement\empty\else
       \doPDFgetobjectreference{SYM}\commalistelement\PDFobjectreference
       \edef\R{\ifFDFvalues\R /#1 \fi\PDFobjectreference\space}%
     \fi
     \dogetcommacommandelement3\from#2\to\commalistelement
     \ifx\commalistelement\empty\else
       \doPDFgetobjectreference{SYM}\commalistelement\PDFobjectreference
       \edef\D{\ifFDFvalues\D /#1 \fi\PDFobjectreference\space}%
       \def\FDFappearance{/H /P }%
     \fi
   \fi}

\def\redoFDFappearance#1%
  {\ifx#1\empty\else
     \dogetcommacommandelement3\from#1\to\commalistelement
     \ifx\commalistelement\empty\else
       \def\FDFappearance{/H /P }%
     \fi
   \fi}

\def\doFDFappearance#1#2#3%
  {\ifcase#3\relax % push only field
     \edef\yes{#2}%
     \let\no\empty
   \else % on / off field
     \dogetcommacommandelement1\from#2,\to\yes
     \dogetcommacommandelement2\from#2,\to\no
   \fi
   \def\FDFappearance{/H /N}%
   \doifobjectfoundelse{FDF}{ap:#1:\yes:\no}
     {\redoFDFappearance\yes
      \redoFDFappearance\no}
     {\presetobject{FDF}{ap:#1:\yes:\no}% funny hack
      \let\N\empty\let\R\empty\let\D\empty
      \dodoFDFappearance{#1}\yes
      \dodoFDFappearance{Off}\no
      \doPDFdictionaryobject class FDF name {ap:#1:\yes:\no} data
        {\ifx\N\empty\else/N \ifFDFvalues<<\N>>\else\N\fi\fi
         \ifx\R\empty\else/R \ifFDFvalues<<\R>>\else\R\fi\fi
         \ifx\D\empty\else/D \ifFDFvalues<<\D>>\else\D\fi\fi}}%
   \doPDFgetobjectreference{FDF}{ap:#1:\yes:\no}\PDFobjectreference
   \edef\FDFappearance{\FDFappearance /AP \PDFobjectreference}}

%\def\doFDFdefault#1#2%
%  {\dogetcommacommandelement1\from#1,\to\commalistelement
%   \dogetcommacommandelement1\from\commalistelement\to\commalistelement
%   \doifelse{\commalistelement}{#2} % kan ook met \ifx
%     {\def\FDFdefault{On}}{\def\FDFdefault{Off}}}

\def\doFDFdefault#1#2%
  {\doifelse{#2}{1}{\def\FDFdefault{On}}{\def\FDFdefault{Off}}}

%D The three appearances {\em normal}, \type{roll over} and
%D \type{push down} are passed as comma separated triplets,
%D that is, the second argument can look like:
%D
%D \starttypen
%D {yes,ok,fine},{no,rubish,awful}
%D \stoptypen

%D \macros
%D   {doFDFdefinefieldset,doFDFgetfieldset,doFDFiffieldset}
%D
%D Field sets, the ones we use in submitting and resetting
%D fields, are implemented using the next low level specials:
%D
%D \starttypen
%D \doFDFdefinefieldset{TAG}{name,name,...}
%D \doFDFgetfieldset{TAG}
%D \doFDFiffieldset{TAG}{sequence}
%D \stoptypen

\def\doFDFdefinefieldset#1#2% tag commalist
  {\let\FDFfieldset\empty
   \def\docommando##1%
     {\doPDFgetobjectreference{FDF}{##1}\PDFobjectreference
      \edef\FDFfieldset{\FDFfieldset\PDFobjectreference\space}}%
   \processcommacommand[#2]\docommando % nb: command
   \setevalue{FDF:set:#1}{\FDFfieldset}}

\def\doFDFgetfieldset#1%
  {\getvalue{FDF:set:#1}}

\def\doFDFiffieldset#1#2%
  {\ifundefined{FDF:set:#1}\else#2\fi}

%D In the goto specials we took care of secondary references.
%D Here we define the macros used.

\def\doPDFresetgotowhereever%
  {\global\let\secondaryPDFreferences\empty}

\doPDFresetgotowhereever % just to be sure

% we can (in etex) share more by testing on this

\def\savesecondaryPDFreference#1%
 %{\setxvalue{PDF-SR:\the\nofsecondaryreferences}{#1}}
  {\@EA\xdef\csname PDF-SR:\the\nofsecondaryreferences\endcsname{#1}}

\def\savesecondaryPDFreference % #1 == \action
  {\global\@EA\let\csname PDF-SR:\the\nofsecondaryreferences\endcsname}

%\def\getsecondaryPDFreferences%
%  {\ifcase\nofsecondaryreferences\else
%    %\doifdefined{PDF-SR:\the\nofsecondaryreferences}
%     \xdef\secondaryPDFreferences%
%       {/Next << \csname PDF-SR:\the\nofsecondaryreferences\endcsname\space
%                 \secondaryPDFreferences >>}%
%     \global\advance\nofsecondaryreferences \minusone
%     \expandafter\getsecondaryPDFreferences
%   \fi}

% test should happen in core-ref

\beginETEX \ifcsname

\def\getsecondaryPDFreferences%
  {\ifcase\nofsecondaryreferences\else
     \ifcsname PDF-SR:\the\nofsecondaryreferences\endcsname
       \xdef\secondaryPDFreferences%
         {/Next << \csname PDF-SR:\the\nofsecondaryreferences\endcsname\space
                   \secondaryPDFreferences >>}%
     \fi
     \global\advance\nofsecondaryreferences \minusone
     \expandafter\getsecondaryPDFreferences
   \fi}

\endETEX

\beginTEX

\def\getsecondaryPDFreferences%
  {\ifcase\nofsecondaryreferences\else
     \@EA\ifx\csname PDF-SR:\the\nofsecondaryreferences\endcsname\relax\else
       \xdef\secondaryPDFreferences%
         {/Next << \csname PDF-SR:\the\nofsecondaryreferences\endcsname\space
                   \secondaryPDFreferences >>}%
     \fi
     \global\advance\nofsecondaryreferences \minusone
     \expandafter\getsecondaryPDFreferences
   \fi}

\endTEX

%D \macros
%D   {loadFDFfields, showFDFfields,
%D    getFDFfield, setFDFfield}
%D
%D Once filled in, we can export or submit the field in the
%D \FDF\ file format. Such a file can be loaded by
%D
%D \starttypen
%D \loadFDFfields{fiel-ini}
%D \stoptypen
%D
%D or inspected by
%D
%D \starttypen
%D \showFDFfields{fiel-ini}
%D \stoptypen
%D
%D After both commands, one can use
%D
%D \starttypen
%D \getFDFfield{name}
%D \setFDFfield{name}{value}
%D \stoptypen
%D
%D to inspect and overrule the data.
%D
%D By default \CONTEXT\ calls the perl script \type{fdf2tex}.
%D This script reads the \type{fdf} file and produces a file
%D named \type{filename.fdt}. If one disables the call to this
%D script, by saying:
%D
%D \starttypen
%D \runFDFconverterfalse
%D \stoptypen
%D
%D or when \CONTEXT\ cannot find the \type{fdt} file, it tries
%D to interpret the \type{fdf} file directly. Both mechanisms
%D are rather crude.

\newif\ifrunFDFconverter \runFDFconvertertrue

%D The \PERL\ script produces a file formatted as:
%D
%D \starttypen
%D \beginFDFobject
%D \beginFDFdata
%D \beginFDFfields
%D \FDFfield[name=,value=]
%D \endFDFfields
%D \endFDFdata
%D \endFDFobject
%D \stoptypen
%D
%D One reason for using key value pairs is that we cannot be
%D sure or the order in which the name and value are given
%D (actually the reverse).

\def\PERLloadFDFfields#1% will become obsolete soon
  {\bgroup
   \global\let\allFDFfields\empty
   \ifrunFDFconverter
     \executesystemcommand{fdf2tex #1}%
     \let\beginFDFobject\relax \let\endFDFobject\relax
     \let\beginFDFdata  \relax \let\endFDFdata  \relax
     \let\beginFDFfields\relax \let\endFDFfields\relax
     \def\FDFfield[##1]%
       {\getparameters[FDF][##1]%
        \doglobal\addtocommalist\FDFname\allFDFfields
        \global\setFDFfield{\FDFname}{\FDFvalue}}%
     \ReadFile{#1.fdt}%
   \fi
   \egroup}

%D The next macro does the same job, but now in the \TEX\ way
%D of doing things. Easy eh?

\bgroup

\catcode`\/=\@@other
\global\let\normalslash=/
\catcode`\/=\@@escape

\gdef\TEXloadFDFfields#1% will become obsolete due to XFDF
  {\bgroup
   \setbox0=\hbox
     {\global\let\allFDFfields\empty
      \scratchcounter=0
      \escapechar=-1
      \catcode`\/=\@@escape
      \catcode`\(=\@@begingroup
      \catcode`\)=\@@endgroup
      \catcode`\%=\@@letter
      \let/A =\relax \let/AS =\relax \let/Kids=\relax \let/Fields=\relax
      \let/F =\relax \let/ID =\relax \let/SetF=\relax \let/setFf =\relax
      \let/Ff=\relax \let/Opt=\relax \let/ClrF=\relax \let/ClrFf =\relax
      \let/AP=\relax \let/FDF=\relax \let/Root=\relax
      \def/T##1{\check\Title{##1}}
      \def/V{\bgroup\catcode`\/=\@@other\futurelet\next/doV}
      \def/doV{\ifx\next\normalslash\@EA/doVb\else\@EA/doVa\fi}
      \def/doVa##1{\egroup\check\Value{##1}}
      \def/doVb##1##2 {\egroup\check\Value{##2}} % watch the space
      \def\check##1##2%
        {\def##1{##2}
         \advance\scratchcounter by 1
         \ifodd\scratchcounter \else
           \convertcommand\Title\to\asciiA
           \global\setFDFfield{\asciiA}{\Value}
           \doglobal\addtocommalist\Title\allFDFfields
         \fi}
      \ReadFile{#1.fdf}}%
   \egroup}

\egroup

%D Whatever mechanism is used, the next macros can be used to
%D fetch the values.

\def\getFDFfield  #1{\getvalue {FDFfield::#1}}
\def\setFDFfield#1#2{\setevalue{FDFfield::#1}{#2}}

%D Of course the fields are only present when the file is
%D loaded.

\def\loadFDFfields#1%
  {\PERLloadFDFfields{#1}%
   \ifx\allFDFfields\empty
     \TEXloadFDFfields{#1}%
   \fi}

\def\showFDFfields#1%
  {\bgroup
   \loadFDFfields{#1}
   \def\docommando##1{\par##1 = \getFDFfield{##1}\par}%
   \processcommacommand[\allFDFfields]\docommando
   \egroup}

%D \macros
%D   {sanitizePDFencoding,sanitizePDFdocencoding}
%D
%D We already dealt with the encoding vector. Conversion from
%D \TEX\ \ASCII\ encoding to the other one, is accomplished by
%D the next few macros. Wach out: we don't group here.

%D This will be reimplemented using the mapping mechanism.

\def\enablePDFdocencoding
  {\reducetocoding[pdfdoc]\simplifycommands}

\long\def\sanitizePDFdocencoding#1\to#2%
  {\enablePDFcrlf
   \enablePDFdocencoding
  %\honorunexpanded % otherwise problems with "e etc in de
   \edef#2{#1}}

\bgroup
\catcode`\^^M=\@@active
\gdef\enablePDFcrlf%
  {\def\\{\string\r}%
   \def\par{\\\\}%
   \catcode`\^^M=\@@active%
   \let^^M=\\}
\egroup

\let\sanitizePDFencoding\sanitizePDFdocencoding

%D A bit out of place, but useful:

\newevery\everysetfield\relax

\appendtoksonce
  \enablePDFdocencoding
  \enablePDFcrlf
\to \everysetfield

%D \macros
%D   {doPDFinsertcomment}
%D
%D An example its use is the next special, one that deals with
%D text annotations.

\def\PDFcommentNew       {/Insert}
\def\PDFcommentBalloon   {/Comment}
\def\PDFcommentAddition  {/NewParagraph}
\def\PDFcommentHelp      {/Help}
\def\PDFcommentParagraph {/Paragraph}
\def\PDFcommentKey       {/Key }

\long\def\doPDFinsertcomment#1#2#3#4#5#6#7#8%
  {\bgroup % title width height color open symbol collect data
   \doifelsenothing{#1}
     {\let\PDFidentifier\empty}
     {\def\PDFidentifier{/T (#1)}}%
   \doifelsenothing{#4}
     {\let\PDFattributes\empty}
     {\def\PDFattributes{/C \FDFcolor{#4}}}%
   \doifundefinedelse{PDFcomment#6}
     {\let\PDFcomment\empty}
     {\def\PDFcomment{/Name \getvalue{PDFcomment#6} }}%
   \sanitizePDFencoding#8\to\PDFdata
   \setbox\scratchbox=\vbox to #3
     {\vfill
      \doPDFannotation width #2 height #3 data
        {/Subtype /Text
         \ifcase#5 \else/Open true\fi
         /Contents \ifPDFunicode <\PDFdata> \else(\PDFdata) \fi
         \PDFcomment
         \PDFidentifier
         \PDFattributes}}%
   \wd\scratchbox\zeropoint
   \ht\scratchbox\zeropoint
   \dp\scratchbox\zeropoint
   \box\scratchbox
   \egroup}

\startmode[atpragma]

% todo: scale annot relative to paper width to get
%       dimensions honored

\newcounter\nofFDFcomments

\newif\ifPDFpopupcomments   \PDFpopupcommentstrue

\newbox\PDFcommentbox

\def\doPDFflushcomments
  {\box\PDFcommentbox}

\long\def\doPDFinsertcomment#1#2#3#4#5#6#7#8%
  {\bgroup % title width height color open symbol collect data
   \doifelsenothing{#1}
     {\let\PDFidentifier\empty}
     {\def\PDFidentifier{/T (#1)}}%
   \doifelsenothing{#4}
     {\let\PDFattributes\empty}
     {\def\PDFattributes{/C \FDFcolor{#4}}}%
   \def\width {18pt}%
   \def\height{24pt}%
   \doifundefinedelse{PDFcomment#6}
     {\doifelsenothing{#6}
        {\let\PDFcomment\empty}
        {\presetPDFcommentappearance{#6}}}
     {\def\PDFcomment{/Name \getvalue{PDFcomment#6} }}%
   \sanitizePDFencoding#8\to\PDFdata
   \setbox\scratchbox=\vbox to #3
     {\vfill
      \ifPDFpopupcomments
        \doglobal\increment\nofFDFcomments
        \doifobjectreferencefoundelse{FDF}{c:\nofFDFcomments}
          {\doPDFgetobjectreference{FDF}{c:\nofFDFcomments}\PDFobjectreference
           \donetrue}
          {\donefalse}%
        \ifdone
          \setbox\scratchbox\hbox
            {\doPDFannotation width #2 height #3 data % text window
               {/Subtype /Popup
                /Parent \PDFobjectreference}}%
          \ifcase#7\relax
            \vbox to \height{\forgetall\vskip#3\box\scratchbox\vss}%
          \else % incredible trial and error hack
            \global\setbox\PDFcommentbox\vbox
              {\hsize#2%
               \forgetall
               \vsmash{\box\PDFcommentbox}
               \box\scratchbox}%
          \fi
        \fi
        \doPDFannotationobject class FDF name {c:\nofFDFcomments}
            width {\width} height {\height} data
          {/Subtype /Text
           \ifcase#5 \else/Open true\fi
           \ifdone /Popup \the\pdflastannot\space 0 R\fi
           /Contents \ifPDFunicode <\PDFdata> \else(\PDFdata) \fi
           \PDFcomment
           \PDFidentifier
           \PDFattributes}%
        \vskip#3%
        \vskip-\height
      \else
        \doPDFannotation width #2 height #3 data
          {/Subtype /Text
           \ifcase#5 \else/Open true\fi
           /Contents \ifPDFunicode <\PDFdata> \else(\PDFdata) \fi
           \PDFcomment
           \PDFidentifier
           \PDFattributes}%
      \fi}%
   \wd\scratchbox\zeropoint
   \ht\scratchbox\zeropoint
   \dp\scratchbox\zeropoint
   \box\scratchbox
   \egroup}

\def\presetPDFcommentappearance#1%
  {\getfromcommacommand[#1][1]\let\PDFcommentnormalsymbol\commalistelement
   \getfromcommacommand[#1][2]\let\PDFcommentdownsymbol  \commalistelement
   \doifsymboldefinedelse\PDFcommentnormalsymbol
     {\doifsymboldefinedelse\PDFcommentdownsymbol
        {\dopresetPDFcommentappearance
           \PDFcommentnormalsymbol\PDFcommentdownsymbol}
        {\dopresetPDFcommentappearance
           \PDFcommentnormalsymbol\PDFcommentnormalsymbol}}
     {\doifsymboldefinedelse\PDFcommentdownsymbol
        {\dopresetPDFcommentappearance
           \PDFcommentdownsymbol\PDFcommentdownsymbol}
        {\let\PDFcomment\empty}}}

\def\dopresetPDFcommentappearance#1#2%
  {\dopresetfieldsymbol{#1}%
   \dopresetfieldsymbol{#2}%
   \setbox\scratchbox\hbox{\symbol[#1]}%
   \edef\width {\the\wd\scratchbox}%
   \edef\height{\the\ht\scratchbox}%
   \doPDFgetobjectreference{SYM}{#1}\FDFcommentNappearance
   \doPDFgetobjectreference{SYM}{#2}\FDFcommentDappearance
   \edef\PDFcomment
     {/AP <</N \FDFcommentNappearance /D \FDFcommentDappearance>>}}

\stopmode

%D Hooked into \CONTEXT, this special supports
%D
%D \starttypen
%D \startcomment
%D   hello beautiful\\world
%D \stopcomment
%D
%D \startcomment[hello]
%D   de \'e\'erste keer
%D   the f\'irst time
%D \stopcommen
%D
%D \startcommentaar[hallo][kleur=groen,breedte=4cm,hoogte=3cm]
%D   first
%D
%D   second
%D \stopcommentaar
%D \stoptypen
%D
%D So, special characters, forced linebreaks using \type{\\}
%D and \type{\par} are handled in the appropriate way.

%D \macros
%D  {doPDFovalbox}
%D
%D For drawing ovals we use quite raw \PDF\ code. The next
%D implementation does not differ that much from the one
%D implemented in the \POSTSCRIPT\ driver.

\def\doPDFovalcalc#1#2#3%
  {\dimen2=#1%
   \advance\dimen2 #2\relax
   \PointsToBigPoints{\dimen2}#3}

\def\doPDFovalbox#1#2#3#4#5#6#7% todo: \scratchdimen/\scatchbox
  {\bgroup
   \dimen0=#4\divide\dimen0 2
   \doPDFovalcalc{0pt}{+\dimen0}\xmin
   \doPDFovalcalc{#1}{-\dimen0}\xmax
   \doPDFovalcalc{#2}{-\dimen0}\ymax
   \doPDFovalcalc{-#3}{+\dimen0}\ymin
   \advance\dimen0 by #5%
   \doPDFovalcalc{0pt}{+\dimen0}\xxmin
   \doPDFovalcalc{#1}{-\dimen0}\xxmax
   \doPDFovalcalc{#2}{-\dimen0}\yymax
   \doPDFovalcalc{-#3}{+\dimen0}\yymin
   \doPDFovalcalc{#4}{\zeropoint}\stroke
   \doPDFovalcalc{#5}{\zeropoint}\radius
   \edef\dostroke{#6}%
   \edef\dofill{#7}%
   \setbox0\hbox
     {\ifnum\dostroke\dofill>0
        \ifPDFstrokecolor\else\ifnum\dostroke=1
          \writestatus\m!colors{pdf stroke color will fail}\wait
        \fi\fi
        \PDFcode
          {q
           \stroke\space w
           \xxmin\space \ymin\space  m
           \xxmax\space \ymin\space  l
           \xmax \space \ymin\space  \xmax\space  \yymin\space y
           \xmax \space \yymax\space l
           \xmax \space \ymax\space  \xxmax\space \ymax\space  y
           \xxmin\space \ymax\space  l
           \xmin \space \ymax\space  \xmin\space  \yymax\space y
           \xmin \space \yymin\space l
           \xmin \space \ymin\space  \xxmin\space \ymin\space  y
           \ifnum\dostroke=1 S \fi
           \ifnum\dofill=1 f \fi
           Q}%
      \fi}%
   \wd0=#1\ht0=#2\dp0=#3\box0
   \egroup}

%D \macros
%D   {doPDFstartgraymode,doPDFstopgraymode,
%D    doPDFstartrgbcolormode,doPDFstartcmykcolormode,doPDFstartgraycolormode,
%D    doPDFstopcolormode}
%D
%D In \PDF\ there are two color states, one for strokes and one
%D for fills. This means that we have to set the color in a
%D rather redundant looking way. Unfortunately this makes the
%D \PDF\ file much larger than needed. We can save few bytes
%D by not setting the stroke color. Due to zip compression we
%D only save a few percent.

% \newif\ifPDFstrokecolor \PDFstrokecolortrue

\def\doPDFstartgraymode#1%
  {\PDFcode{#1 g\ifPDFstrokecolor\space#1 G\fi}}

\def\doPDFstopgraymode
  {\PDFcode{0 g\ifPDFstrokecolor\space0 G\fi}}

\def\doPDFstartrgbcolormode#1#2#3%
  {\PDFcode{#1 #2 #3 rg\ifPDFstrokecolor\space#1 #2 #3 RG\fi}}

\def\doPDFstartcmykcolormode#1#2#3#4%
  {\PDFcode{#1 #2 #3 #4 k\ifPDFstrokecolor\space#1 #2 #3 #4 K\fi}}

\def\doPDFstartgraycolormode#1%
  {\PDFcode{#1 g\ifPDFstrokecolor\space#1 G\fi}}

\def\doPDFstartspotcolormode#1#2%
  {\PDFcode{/#1 CS #2 SC /#1 cs #2 sc}}

\def\doPDFstopcolormode
  {\PDFcode{0 g\ifPDFstrokecolor\space0 G\fi}}

%D We need to register the spot colors and their fallbacks.

% we cannot use /DeviceN since GS <=7.21 breaks on it
% and Jaws does not handle it at all {[/DeviceN [/All|/None]
% /Device#2 \the\pdflastobj\space0 R]} so we use separation
% colors that work and print ok

\def\doPDFregistersomespotcolor#1#2#3#4%
  {\writestatus\m!systems{missing spot color definition}\wait}

\def\doPDFregisterrgbspotcolor#1#2#3#4%
  {\doPDFregistersomespotcolor
     {#1}{RGB}{[0.0 1.0 0.0 1.0 0.0 1.0]}%
     {{dup #2 mul exch dup #3 mul exch #4 mul}}}

\def\doPDFregistercmykspotcolor#1#2#3#4#5%
  {\doPDFregistersomespotcolor
     {#1}{CMYK}{[0.0 1.0 0.0 1.0 0.0 1.0 0.0 1.0]}%
     {{dup #2 mul exch dup #3 mul exch dup #4 mul exch #5 mul}}}

\def\doPDFregistergrayspotcolor#1#2%
  {\doPDFregistersomespotcolor
     {#1}{Gray}{[0.0 1.0]}%
     {{pop}}}

%D \macros
%D   {doPDFstartrotation,doPDFstoprotation}
%D
%D Rotating some text can be accomplished by setting the first
%D four elements of the transform matrix. We only support some
%D fixed angles. The \type{q}'s take care of grouping.

\def\doPDFstartrotation#1%
  {\PDFcode{q}%
   \processaction
     [#1]
     [ 90=>\PDFcode{ 0  1 -1  0 0 0 cm},
      180=>\PDFcode{-1  0  0 -1 0 0 cm},
      270=>\PDFcode{ 0 -1  1  0 0 0 cm},
      360=>\PDFcode{ 1  0  0  1 0 0 cm}]}

\def\doPDFstoprotation%
  {\PDFcode{Q}}

%D \macros
%D   {doPDFstartscaling,doPDFstopscaling}
%D
%D Scaling is rather straightforward:

\def\doPDFstartscaling#1#2%
  {\PDFcode{q #1\space 0 0 #2\space 0 0 cm}}

\def\doPDFstopscaling%
  {\PDFcode{Q}}

%D \macros
%D   {doPDFstartmirroring,doPDFstopmirroring}
%D
%D Mirroring is implemented in a similar way:

\def\doPDFstartmirroring%
  {\PDFcode{-1 0 0 1 0 0 cm}}

\def\doPDFstopmirroring%
  {\PDFcode{-1 0 0 1 0 0 cm}}

%D \macros
%D   {doPDFstartnegative,doPDFstopnegative}
%D
%D When producing output for an image setter, sometimes negative
%D output is needed.

\def\doPDFstartnegative
  {\ifx\initializePDFnegative\undefined\else
     \initializePDFnegative
     \PDFcode{/GSnegative gs}%
   \fi}

\def\doPDFstopnegative
  {\ifx\initializePDFnegative\undefined\else
     \PDFcode{/GSpositive gs}%
   \fi}

%D Transparency support (experimental):

\def\PDFtransparancydictionary#1#2#3% type fraction extras
  {<</Type /ExtGState
     /ca #2 /CA #2
     /BM /\ifcase#1 Normal\or Normal\or Multiply\or Screen\or
          Overlay\or SoftLight\or HardLight\or ColorDodge\or
          ColorBurn\or Darken\or Lighten\or Difference\or
          Exclusion\else Compatible\fi
     #3>>}

\newif\ifPDFtransparencysupported

\def\dodoPDFstarttransparency#1#2%
  {\presetPDFtransparency{#1}{#2}%
   \PDFcode{\PDFtransparencyidentifier\space gs }}

\def\dodoPDFstoptransparency
  {\PDFcode{/Tr0 gs }}

\def\doPDFstarttransparency
  {\ifPDFtransparencysupported
     \global\let\doPDFstarttransparency\dodoPDFstarttransparency
     \global\let\doPDFstoptransparency \dodoPDFstoptransparency
     \initializetransparency
     \expandafter\doPDFstarttransparency
   \else
     \expandafter\gobbletwoarguments
   \fi}

\let\doPDFstoptransparency\relax

%D These use:

\let\PDFtransparencyresetreference \empty
\let\PDFtransparencyresetidentifier\empty

\let\PDFtransparencyreference \empty
\let\PDFtransparencyidentifier\empty

\let\presetPDFtransparency \gobbletwoarguments
\let\initializetransparency\relax

%D New trickery:

\definespecial\dostartgraphicgroup{\PDFcode{q}}
\definespecial\dostopgraphicgroup {\PDFcode{Q}}

%D And that was all.

\stopspecials

\protect \endinput
