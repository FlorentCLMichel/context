%D \module
%D   [       file=supp-mpe,
%D        version=1999.07.10,
%D          title=\CONTEXT\ Support Macros,
%D       subtitle=METAPOST Special Extensions,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

%D This module is still experimental and deals with some
%D extensions to \METAPOST. When using \POSTSCRIPT\ output,
%D these extensions can be supplied by means of proper
%D preamble definitions, but when producing \PDF\ we have to
%D set up the appropriate datastructures ourselves. It acts as
%D a plug in into \type {supp-pdf}. As soon as we need more
%D extensions, we will generalize these macro. Some 
%D definitions will move to the special drivers. 

\writestatus{loading}{MetaPost Special Extensions}

%D We implement extensions by using the \METAPOST\ special
%D mechanism. Opposite to \TEX's specials, the \METAPOST\ ones
%D are flushed before or after the graphic data, but thereby
%D are no longer connected to a position.
%D
%D We implement specials by overloading the \type {fill}
%D operator. By counting the fills, we can let the converter
%D treat the appropriate fill in a special way. The
%D specification of the speciality can have two forms,
%D determined by the setting of a boolean variable:
%D
%D \starttypen
%D _inline_specials_ := false ; % comment like code (default)
%D _inline_specials_ := true  ; % command like code
%D \stoptypen
%D
%D When the specification is embedded as comment, it looks
%D like:
%D
%D \starttypen
%D %%MetaPostSpecial <size> <data> <number> <identifier>
%D \stoptypen
%D
%D The in||line alternative is more tuned for \POSTSCRIPT,
%D since it permits us to define a macro \type {special}.
%D
%D \starttypen
%D inline  : <data> <number> <identifier> <size> special
%D \stoptypen
%D
%D The \type {identifier} determines what to do, and the data
%D can be used to accomplish this. A type~2 shading function
%D has identifier~2. Alltogether, the number of parameters is
%D specified in \type {size}. The \type {number} is the number
%D of the fill that needs the special treatment. For a type~2
%D and~3 shaded fill, the datablock contains the following
%D data:
%D
%D \starttypen
%D from to n inner_r g b x y        outer_r g b x y
%D from to n inner_r g b x y radius outer_r g b x y radius
%D \stoptypen
%D
%D The implementation below saves the data on the stack in
%D a way similar to the macros in \type {supp-pdf.tex}, and
%D just overload a few already defined handlers. That way,
%D the existing macros are still generic. \voetnoot {Actually,
%D the macros here are just as generic.}
%D
%D Currently the only extension concerns shading, which is
%D accomplished by handling yet another value of \type
%D {\finiMPpath}. The recource disctionary is stored and
%D later picked up by the general \CONTEXT\ figure inclusion
%D macros.

\unprotect

%D The \type {%%MetaPostSpecials: version.revision signal} line
%D triggers this module into handling color specifications kind
%D of special. We need this safeguard for non||special 
%D usage. 

\chardef\MPspecialversion  = 0  % specials when >1
\chardef\MPspecialrevision = 0  % specials when >1
\chardef\MPspecialsignal   = 0  % passed on by graphic

\newcount\currentPDFshade  % 0  % global (document wide) counter
\chardef\inlineMPspecials  = 1  % only needed for stack resetting

\let\currentMPshades\empty

%D This macro handles the special definitions that are 
%D passed as comment. 

\def\dohandleMPspecialcomment#1
  {\setMPargument{#1}%
   \advance\scratchcounter by -1\relax
   \ifcase\scratchcounter\relax
     \handleMPspecialcommand
     \donetrue
     \doresetMPstack
     \let\handleMPsequence=\dohandleMPsequence
     \expandafter\handleMPsequence
   \else
     \expandafter\dohandleMPspecialcomment
   \fi}

\def\handleMPspecialcomment #1 % number of arguments
  {\doresetMPstack
   \scratchcounter=#1\relax
   \ifcase\scratchcounter % when zero, inline shading is used
     \chardef\inlineMPspecials=1
     \let\handleMPsequence=\dohandleMPsequence
     \expandafter\handleMPsequence
   \else
     \chardef\inlineMPspecials=0
     \expandafter\dohandleMPspecialcomment
   \fi}

%D When defined inline, we use another macro to handle the 
%D definitions. Actually, this macro is called by the 
%D previous ones. 

\def\handleMPspecialcommand%
  {\ifcase\inlineMPspecials\or
     \advance\nofMParguments by -1 % pop the size
   \fi
   \doifundefinedelse{\MPspecial}
     {\message{[unknown \MPspecial]}}
     {\getvalue{\MPspecial}}%
   \ifcase\inlineMPspecials
     \doresetMPstack % 0
   \else
     \resetMPstack   % 1
   \fi}

%D This macro triggers special support. Currently, the 
%D version and revision number are not used. Any version number
%D greater than zero will enable special support.  

\def\handleMPspecialscomment #1.#2 #3 % version.revision signal
  {\doresetMPstack
   \chardef\MPspecialversion =#1 
   \chardef\MPspecialrevision=#2 
   \chardef\MPspecialsignal  =#3 
   \let\handleMPsequence=\dohandleMPsequence
   \handleMPsequence}

%D In case of \PDF, we need to prepare resourcs. 

\def\startMPresources%
  {\global\let\currentMPshades\empty
   \ifx\currentPDFresources\empty\else
     \message{[unused resources before shade \the\currentPDFshade]}%
   \fi
   \global\let\currentPDFresources\empty}

\def\stopMPresources%
  {\ifx\currentMPshades\empty
     \global\let\currentPDFresources\empty
   \else
     \xdef\currentPDFresources%
       {/Shading << \currentMPshades >>}%
   \fi}

\def\startMPshading#1%
  {\edef\currentMPspecial{\gMPs{#1}}}

\def\stopMPshading%
  {\global\advance\currentPDFshade by 1
   \setxvalue{obj:Sh:\currentMPspecial}% 
     {/Sh\the\currentPDFshade\space\the\pdflastobj\space0 R }%
   \setxvalue{mps:Sh:\currentMPspecial}%
     {\the\currentPDFshade}}

%D Since colors are not subjected to transformations, we can
%D only use colors as signal. In our case, we use a dummy colored
%D path with a red color component of \type {0.n}, so \type
%D {0.001} is the first path and \type {0.010} the tenth. Since
%D \METAPOST strips trailing zeros, we have to padd the string.

\newif\ifMPcmyk 

\ifx\normalhandleMPrgbcolor\undefined % in case we reload this module

  \let\normalhandleMPrgbcolor \handleMPrgbcolor
  \let\normalhandleMPcmykcolor\handleMPcmykcolor
  \let\normalhandleMPgraycolor\handleMPgraycolor

\fi 

%D When we are using \CONTEXT, we will fall back to the 
%D better color conversion routines. This also has the advantage
%D that we don't have to parse and convert the file. In this 
%D alternative, \type {\!MP} is not (yet) supported. Because
%D we can (for efficiency reasons) turn off strokecolor, 
%D something we cannot do in \METAPOST\ converted code. 

\newif\ifPDFMPstrokecolor \PDFMPstrokecolortrue 

%D [This code should move to meta-ini.]

\ifCONTEXT

  \def\checkPDFMPstrokecolor%
    {\ifPDFMPstrokecolor \PDFstrokecolortrue \fi}

  \def\normalhandleMPrgbcolor%
    {{\checkPDFMPstrokecolor\dostartcolormodeR\gMPa1:\gMPa2:\gMPa3\od}}

  \def\normalhandleMPcmykcolor%
    {{\checkPDFMPstrokecolor\dostartcolormodeC\gMPa1:\gMPa2:\gMPa3:\gMPa4\od}}

  \def\normalhandleMPgraycolor%
    {{\checkPDFMPstrokecolor\dostartcolormodeS\gMPa1\od}}

\fi

% In the previous macros we use the special drivers. A more
% direct approach would have been: 
%
% \def\doPDFstartrgbcolormode#1#2#3%   
%   {\PDFcode{#1 #2 #3 rg #1 #2 #3 RG}}
%
% \def\doPDFstartcmykcolormode#1#2#3#4%
%   {\PDFcode{#1 #2 #3 #4 k #1 #2 #3 #4 K}}
%
% \def\doPDFstartgraycolormode#1%      
%   {\PDFcode{#1 g #1 G}}
%
% \appendtoks
%   \let\dostartrgbcolormode \doPDFstartrgbcolormode
%   \let\dostartcmykcolormode\doPDFstartcmykcolormode
%   \let\dostartgraycolormode\doPDFstartgraycolormode
% \to \everyMPtoPDFconversion

%D Now we can handle special color signals. We only do this 
%D when special are detected. 

\def\MPrgbnumber#1{\expandafter\doMPrgbnumber#1000.0000\relax}
\def\doMPrgbnumber#1.#2#3#4#5\relax{#2#3#4}

%D The naive case looks like: 
%D 
%D \starttypen 
%D \def\handleMPrgbcolor%
%D   {\setMPcolor
%D    \ifcase\MPspecialversion
%D      \resetMPcolor\normalhandleMPrgbcolor
%D    \else\ifnum\MPrgbnumber\lastMPrvalue=\MPspecialsignal
%D      % consider it to be a signal
%D    \else
%D      \resetMPcolor\normalhandleMPrgbcolor
%D    \fi\fi}
%D \stoptypen 
%D
%D However, since we want \CMYK\ support, we will use the 
%D following implementation: 

\def\handleMPrgbcolor%
  {\setMPcolor
   \ifcase\MPspecialversion
     \resetMPcolor\normalhandleMPrgbcolor
   \else\ifnum\MPrgbnumber\lastMPrvalue=\MPspecialsignal\relax
     \ifMPcmyk \ifnum\MPrgbnumber\lastMPgvalue=1 % cmyk color spec
       \doifdefined{mps:k:\number\MPrgbnumber\lastMPbvalue}
         {\getvalue{mps:k:\number\MPrgbnumber\lastMPbvalue}%
          \resetMPcolor\normalhandleMPcmykcolor}%
     \fi \fi 
   \else
     \resetMPcolor\normalhandleMPrgbcolor
   \fi\fi}

\def\handleMPcmykcolor%
  {\resetMPcolor\normalhandleMPcmykcolor}

\def\handleMPgraycolor%
  {\resetMPcolor\normalhandleMPgraycolor}

\def\resetMPcolor%
  {\def\lastMPrvalue{0.0}%
   \def\lastMPgvalue{0.0}%
   \def\lastMPbvalue{0.0}}

\def\setMPcolor%
  {\edef\lastMPrvalue{\gMPa1}%
   \edef\lastMPgvalue{\gMPa2}%
   \edef\lastMPbvalue{\gMPa3}}

\resetMPcolor 

%D Specials are define and recalled using: 

\def\MPspecial%
  {MP special \gMPs\nofMParguments}

\def\defineMPspecial#1#2%
  {\setvalue{MP special #1}{#2}}

%D The path processing macro is slightly extended. 

% \def\processMPpath%
%   {\ifcase\MPspecialversion\else
%      \ifnum\MPrgbnumber\lastMPrvalue=\MPspecialsignal 
%        \scratchcounter=\MPrgbnumber\lastMPbvalue
%        \edef\currentMPspecial{\the\scratchcounter}%
%        \ifnum\finiMPpath=2 
%          \doifdefined{mps:Sh:\currentMPspecial}
%             {\edef\currentMPshade{\getvalue{obj:Sh:\currentMPspecial}}% 
%              \doifinstringelse{\currentMPshade}{\currentMPshades}
%                {}{\xdef\currentMPshades{\currentMPshades\currentMPshade}}% 
%              \chardef\finiMPpath=4 \PDFcode{q /Pattern cs}}%
%        \fi
%      \fi
%    \fi
%    \flushMPpath
%    \closeMPpath
%    \PDFcode
%      {\ifcase\finiMPpath
%         W n\or S\or f\or B\or W n /Sh\getvalue{mps:Sh:\currentMPspecial} sh Q%
%       \fi}%
%    \let\handleMPsequence=\dohandleMPsequence
%    \resetMPstack
%    \nofMPsegments=0
%    \handleMPsequence}

\newtoks \invokeMPspecials

% \def\processMPpath%
%   {\let\extraMPpathcode\empty
%    \ifcase\MPspecialversion\else
%      \ifnum\MPrgbnumber\lastMPrvalue=\MPspecialsignal 
%        \scratchcounter=\MPrgbnumber\lastMPbvalue
%        \edef\currentMPspecial{\the\scratchcounter}%
%        \ifnum\finiMPpath=2 % to outer level 
%          \the\invokeMPspecials
%        \fi
%      \fi
%    \fi
%    \flushMPpath
%    \closeMPpath
%    \PDFcode{\ifcase\finiMPpath W n\or S\or f\or B\else W n\fi \extraMPpathcode}%
%    \let\handleMPsequence=\dohandleMPsequence
%    \resetMPstack
%    \nofMPsegments=0
%    \handleMPsequence}

\def\finishMPpath%
  {\PDFcode
     {\ifcase\finiMPpath W n\or S\or f\or B\else W n\fi 
      \extraMPpathcode}}

\def\processMPpath%
  {\checkMPpath % ! 
   \ifcase\nofMPsegments\else
     \let\extraMPpathcode\empty
     \ifcase\MPspecialversion\else
       \ifnum\MPrgbnumber\lastMPrvalue=\MPspecialsignal 
         \scratchcounter=\MPrgbnumber\lastMPbvalue
         \edef\currentMPspecial{\the\scratchcounter}%
         \ifnum\finiMPpath=2 % to outer level 
           \the\invokeMPspecials
         \fi
       \fi
     \fi
     \flushMPpath
     \closeMPpath
     \finishMPpath
   \fi 
   \let\handleMPsequence=\dohandleMPsequence
   \resetMPstack
   \nofMPsegments=0
   \handleMPsequence}

%D Shading is an example of a more advanced graphic feature,
%D but users will seldom encounter those complications. Here
%D we only show a few simple examples, but many other
%D alternatives are possible by setting up the functions built
%D in \PDF\ in the appropriate way.
%D
%D Shading has to do with interpolation between two or more
%D points or user supplied ranges. In \PDF, the specifications
%D of a shade has to be encapsulated in objects and passed on
%D as resources. This is a \PDF\ level 1.3. feature. One can
%D simulate three dimensional shades as well and define simple
%D functions using a limited set of \POSTSCRIPT\ primitives.
%D Given the power of \METAPOST\ and these \PDF\ features, we
%D can achieve superb graphic effects.
%D
%D Since everything is hidden in \TEX\ and \METAPOST\ graphics,
%D we can stick to high level \CONTEXT\ command, as shown in
%D the following exmples.
%D
%D \startbuffer
%D \startuniqueMPgraphic{CircularShade}
%D   path  p ; p := unitsquare xscaled \overlaywidth yscaled \overlayheight ;
%D   circular_shade(p,0,.2red,.9red) ;
%D \stopuniqueMPgraphic
%D
%D \startuniqueMPgraphic{LinearShade}
%D   path  p ; p := unitsquare xscaled \overlaywidth yscaled \overlayheight ;
%D   linear_shade(p,0,.2blue,.9blue) ;
%D \stopuniqueMPgraphic
%D
%D \startuniqueMPgraphic{DuotoneShade}
%D   path  p ; p := unitsquare xscaled \overlaywidth yscaled \overlayheight ;
%D   linear_shade(p,2,.5green,.5red) ;
%D \stopuniqueMPgraphic
%D \stopbuffer
%D
%D \typebuffer
%D
%D \haalbuffer
%D
%D These graphics can be hooked into the overlay mechanism,
%D which is available in many commands.
%D
%D \startbuffer
%D \defineoverlay[demo 1][\uniqueMPgraphic{CircularShade}]
%D \defineoverlay[demo 2][\uniqueMPgraphic  {LinearShade}]
%D \defineoverlay[demo 3][\uniqueMPgraphic {DuotoneShade}]
%D \stopbuffer
%D
%D \typebuffer
%D
%D \haalbuffer
%D
%D These backgrounds can for instance be applied to \type
%D {\framed}:
%D
%D \startbuffer
%D \setupframed[breedte=3cm,hoogte=2cm,kader=uit]
%D \startcombinatie[3*1]
%D   {\framed[achtergrond=demo 1]{\bfd \white Demo 1}} {}
%D   {\framed[achtergrond=demo 2]{\bfd \white Demo 2}} {}
%D   {\framed[achtergrond=demo 3]{\bfd \white Demo 3}} {}
%D \stopcombinatie
%D \stopbuffer
%D
%D \typebuffer
%D
%D \startregelcorrectie
%D \haalbuffer
%D \stopregelcorrectie
%D
%D There are a few more alternatives, determined by the second
%D parameter passed to \type {circular_shade} and alike.
%D
%D \def\SomeShade#1#2#3#4#5%
%D   {\startuniqueMPgraphic{Shade-#1}
%D      width := \overlaywidth ;
%D      height := \overlayheight ;
%D      path p ; p := unitsquare xscaled width yscaled height ;
%D      #2_shade(p,#3,#4,#5) ;
%D    \stopuniqueMPgraphic
%D    \defineoverlay[Shade-#1][\uniqueMPgraphic{Shade-#1}]%
%D    \framed[achtergrond=Shade-#1,breedte=2cm,hoogte=2cm,kader=uit]{}}
%D
%D \startregelcorrectie
%D \startcombinatie[5*1]
%D   {\SomeShade{10}{circular}{0}{.3blue}{.9blue}} {circular 0}
%D   {\SomeShade{11}{circular}{1}{.3blue}{.9blue}} {circular 1}
%D   {\SomeShade{12}{circular}{2}{.3blue}{.9blue}} {circular 2}
%D   {\SomeShade{13}{circular}{3}{.3blue}{.9blue}} {circular 3}
%D   {\SomeShade{14}{circular}{4}{.3blue}{.9blue}} {circular 4}
%D \stopcombinatie
%D \stopregelcorrectie
%D
%D \blanko
%D
%D \startregelcorrectie
%D \startcombinatie[5*1]
%D   {\SomeShade{20}{circular}{0}{.9green}{.3green}} {circular 0}
%D   {\SomeShade{21}{circular}{1}{.9green}{.3green}} {circular 1}
%D   {\SomeShade{22}{circular}{2}{.9green}{.3green}} {circular 2}
%D   {\SomeShade{23}{circular}{3}{.9green}{.3green}} {circular 3}
%D   {\SomeShade{24}{circular}{4}{.9green}{.3green}} {circular 4}
%D \stopcombinatie
%D \stopregelcorrectie
%D
%D \blanko
%D
%D \startregelcorrectie
%D \startcombinatie[4*1]
%D   {\SomeShade{30}{linear}{0}{.3red}{.9red}} {linear 0}
%D   {\SomeShade{31}{linear}{1}{.3red}{.9red}} {linear 1}
%D   {\SomeShade{32}{linear}{2}{.3red}{.9red}} {linear 2}
%D   {\SomeShade{33}{linear}{3}{.3red}{.9red}} {linear 3}
%D \stopcombinatie
%D \stopregelcorrectie
%D
%D These macros closely cooperate with the \METAPOST\ module
%D \type {mp-spec.mp}, which is part of the \CONTEXT\
%D distribution.
%D
%D The low level (\PDF) implementation is based on the \TEX\
%D based \METAPOST\ to \PDF\ converter. Shading is supported
%D by overloading the \type {fill} operator as implemented
%D earlier. In \PDF\ type~2 and~3 shading functions are
%D specified in terms of:
%D
%D \starttabulatie[|Tl|l|]
%D \NC /Domain \NC sort of meeting range \NC \NR
%D \NC /C0     \NC inner shade \NC \NR
%D \NC /C1     \NC outer shade \NC \NR
%D \NC /N      \NC smaller values, bigger inner circles \NC \NR
%D \stoptabulatie

\def\invokeMPshadespecial%
  {\doifdefined{mps:Sh:\currentMPspecial}
     {\edef\currentMPshade{\getvalue{obj:Sh:\currentMPspecial}}% 
      \doifinstringelse{\currentMPshade}{\currentMPshades}
        {}{\xdef\currentMPshades{\currentMPshades\currentMPshade}}% 
      \def\extraMPpathcode{/Sh\getvalue{mps:Sh:\currentMPspecial} sh Q}%
      \chardef\finiMPpath=0 
      \PDFcode{q /Pattern cs}}}

\appendtoks \invokeMPshadespecial \to \invokeMPspecials

\defineMPspecial{2}
  {\startMPshading{14}% type 2
   \immediate\pdfobj
     {<</FunctionType 2
        /Domain [\gMPs1 \gMPs2]
        /C0 [\gMPs4 \gMPs5 \gMPs6]
        /C1 [\gMPs9 \gMPs{10} \gMPs{11}]
        /N \gMPs3>>}%
   \immediate\pdfobj
     {<</ShadingType 2
        /ColorSpace /DeviceRGB
        /Function \the\pdflastobj\space 0 R
        /Coords [\gMPs7 \gMPs8 \gMPs{12} \gMPs{13}]
        /Extend [true true]>>}%
   \stopMPshading}

\defineMPspecial{3}
  {\startMPshading{16}% type 3
   \immediate\pdfobj
     {<</FunctionType 2
        /Domain [\gMPs1 \gMPs2]
        /C0 [\gMPs4 \gMPs5 \gMPs6]
        /C1 [\gMPs{10} \gMPs{11} \gMPs{12}]
        /N \gMPs3>>}%
   \immediate\pdfobj
     {<</ShadingType 3
        /ColorSpace /DeviceRGB
        /Function \the\pdflastobj\space 0 R
        /Coords [\gMPs7 \gMPs8 \gMPs9 \gMPs{13} \gMPs{14} \gMPs{15}]
        /Extend [true true]>>}%
   \stopMPshading}

%D Figure inclusion is kind of strange to \METAPOST, but when 
%D Santiago Muelas started discussing this with me, I was able
%D to cook up a solution using specials. 

\def\invokeMPfigurespecial%
  {\getvalue{mps:gr:\currentMPspecial}} % or \relax 

\appendtoks \invokeMPfigurespecial \to \invokeMPspecials

\defineMPspecial{10}
  {\setxvalue{mps:gr:\gMPs8}%
     {\noexpand\handleMPfigurespecial
        {\gMPs1}{\gMPs2}{\gMPs3}{\gMPs4}{\gMPs5}{\gMPs6}{\gMPs7}%
      \noexpand\setxvalue{mps:gr:\gMPs8}{}}}

% \def\handleMPfigurespecial#1#2#3#4#5#6#7%
%   {\vbox to 0pt
%      {\vss
%       \hbox to 0pt 
%         {\pdfliteral{q #1 #2 #3 #4 #5 #6 cm}% 
%          \pdfimage width 1bp height 1bp {#7}% maybe 10 is better 
%          \pdfliteral{Q}% 
%          \hss}}}
% 
% better, since xform reuse 

\def\handleMPfigurespecial#1#2#3#4#5#6#7%
  {\vbox to \!!zeropoint
     {\vss
      \hbox to \!!zeropoint
        {\ifcase\pdfoutput\or % will be hooked into the special driver
           \doiffileelse{#7}
             {\doifundefinedelse{mps:x:#7}
                {\immediate\pdfximage width 1bp height 1bp {#7}% 
                 \setxvalue{mps:x:#7}{\pdfrefximage\the\pdflastximage}}%
                {\message{[reusing figure #7]}}% 
              \pdfliteral{q #1 #2 #3 #4 #5 #6 cm}% 
              \rlap{\getvalue{mps:x:#7}}%
              \pdfliteral{Q}}
             {\message{[unknown figure #7]}}% 
         \fi
         \hss}}}

%D An example of using both special features is the 
%D following. 
%D
%D \starttypen 
%D \startMPpage 
%D   externalfigure "hakker1b.png" scaled 22cm rotated  10 shifted (-2cm,0cm); 
%D   externalfigure "hakker1b.png" scaled 10cm rotated -10 ; 
%D   externalfigure "hakker1b.png" scaled  7cm rotated  45 shifted (8cm,12cm) ; 
%D   path p ; p := unitcircle xscaled 15cm yscaled 20cm;
%D   path q ; q := p rotatedaround(center p,90) ;   
%D   path r ; r := buildcycle(p,q) ; clip currentpicture to r ; 
%D   path s ; s := boundingbox currentpicture enlarged 5mm ; 
%D   picture c ; c := currentpicture ; currentpicture := nullpicture ; 
%D   circular_shade(s,0,.2red,.9red) ;
%D   addto currentpicture also c ; 
%D \stopMPpage
%D \stoptypen 

%D This is some experimental hyperlink driver that I wrote 
%D for Mark Wicks.

\defineMPspecial{20}
  {\setxvalue{mps:hl:\gMPs6}%
     {\noexpand\handleMPhyperlink
        {\gMPs1}{\gMPs2}{\gMPs3}{\gMPs4}{\gMPs5}%
      \noexpand\setxvalue{mps:hl:\gMPs6}{}}}

\def\handleMPhyperlink#1#2#3#4#5%
  {%\ifcase\pdfoutput\or
     \setbox\scratchbox=\hbox 
       {\setbox\scratchbox=\null
        \scratchdimen=#1bp\scratchdimen=-\scratchdimen
        \advance\scratchdimen#3bp
        \wd\scratchbox=\scratchdimen
        \scratchdimen=#2bp\scratchdimen=-\scratchdimen
        \advance\scratchdimen#4bp
        \ht\scratchbox=\scratchdimen
        \incolorfalse 
        \gotobox{\box\scratchbox}[#5]}%
     \setbox\scratchbox=\hbox
       {\scratchdimen\MPxoffset  bp \advance\scratchdimen#1bp 
        \hskip\scratchdimen
        \scratchdimen=\MPyoffset bp \advance\scratchdimen#2bp
        \raise\scratchdimen\box\scratchbox}%
     \smashbox\scratchbox
     \box\scratchbox
   }%\fi}

\def\invokeMPhyperlinkspecial%
  {\getvalue{mps:hl:\currentMPspecial}} % or \relax 

\appendtoks \invokeMPhyperlinkspecial \to \invokeMPspecials

%D Special number~1 is dedicated to \CMYK\ support. If you 
%D want to know why: look at this: 
%D 
%D \startbuffer[mp]
%D   fill fullcircle xyscaled (3cm,1cm) withcolor \MPcolor{test} ;
%D \stopbuffer
%D 
%D \startbuffer[cmyk]
%D \startcombinatie[4*1]
%D   {\definecolor[test][c=1,y=.3,k=.3] \processMPbuffer[mp]} {c=1 y=.3 k=.3} 
%D   {\definecolor[test][c=.9,y=.15]    \processMPbuffer[mp]} {c=.9 y=.15}    
%D   {\definecolor[test][c=.25,y=.8]    \processMPbuffer[mp]} {c=.25 y=.8}   
%D   {\definecolor[test][c=.45,y=.1]    \processMPbuffer[mp]} {c=.45 y=.1}  
%D \stopcombinatie
%D \stopbuffer
%D 
%D \plaatsfiguur
%D   {\CMYK\ support disabled, 
%D    conversion to \RGB.}
%D   {\setupcolors[cmyk=nee,status=start]\haalbuffer[cmyk]}
%D 
%D \plaatsfiguur
%D   {\CMYK\ support enabled, 
%D    no support in \METAPOST.}
%D   {\setupcolors[cmyk=ja,mpcmyk=nee,status=start]\haalbuffer[cmyk]}
%D 
%D \plaatsfiguur
%D   {\CMYK\ support enabled, 
%D    no conversion to \RGB, 
%D    support in \METAPOST}
%D   {\setupcolors[cmyk=ja,status=start]\haalbuffer[cmyk]}

\defineMPspecial{1}
  {\ifMPcmyk 
     \setxvalue{mps:k:\gMPs1}{\noexpand\setMPcmyk\gMPs2 \gMPs3 \gMPs4 \gMPs5 }%
   \fi}

\def\setMPcmyk#1 #2 #3 #4 %
  {\setvalue{\@@MP01}{#1}%
   \setvalue{\@@MP02}{#2}%
   \setvalue{\@@MP03}{#3}%
   \setvalue{\@@MP04}{#4}}

%D This special (number 50) passes positions to a tex file. 
%D This method uses a two||pass approach an (mis|)|used the 
%D context positioning macros. In \type {core-pos} we will 
%D implement the low level submacro needed. 
%D
%D \startbuffer
%D \definelayer[test] 
%D
%D \setlayer
%D   [test]
%D   [x=\MPx{somepos-1},y=\MPy{somepos-1}]
%D   {Whatever we want here!}
%D 
%D \setlayer
%D   [test]
%D   [x=\MPx{somepos-2},y=\MPy{somepos-2}]
%D   {Whatever we need there!}
%D 
%D \startuseMPgraphic{oeps}
%D   draw fullcircle scaled 6cm withcolor red ; 
%D   register ("somepos-1",1cm,2cm,center currentpicture) ; 
%D   register ("somepos-2",4cm,3cm,(-1cm,-2cm)) ; 
%D \stopuseMPgraphic
%D 
%D \framed[background=test,offset=overlay]{\useMPgraphic{oeps}}
%D \stopbuffer
%D 
%D \typebuffer 
%D 
%D Here the width and height are not realy used, but one can
%D imagine situations where tex has to work with values 
%D calculated by \METAPOST.  
%D 
%D \startlinecorrection
%D \getbuffer
%D \stoplinecorrection
%D
%D Later we will implement a more convenient macro: 
%D
%D \starttyping 
%D \setMPlayer [test] [somepos-1] {Whatever we want here!}
%D \setMPlayer [test] [somepos-2] {Whatever we need there!}
%D \stoptyping
 
\ifx\dosavepositionwhd\undefined
  \let\dosavepositionwhd\gobblesevenarguments
\fi

\defineMPspecial{50} % x y width height label 
  {\bgroup
   \scratchdimen\MPllx bp \scratchdimen=-\scratchdimen
   \advance\scratchdimen\gMPs1bp 
   \edef\x{\number\scratchdimen}%
   \scratchdimen\gMPs2bp \scratchdimen=-\scratchdimen
   \advance\scratchdimen\MPury bp 
   \edef\y{\number\scratchdimen}%
   \scratchdimen=\gMPs3bp
   \edef\w{\number\scratchdimen}%
   \scratchdimen=\gMPs4bp
   \edef\h{\number\scratchdimen}%
   \dosavepositionwhd{\gMPs5}{0}{\x}{\y}{\w}{\h}{0}%
   \egroup}

\protect \endinput
