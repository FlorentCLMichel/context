if not modules then modules = { } end modules ['lxml-mms'] = {
    version   = 1.001,
    author    = "Hans Hagen, PRAGMA-ADE, Hasselt NL",
    comment   = "written together with Mikael Sundqvist",
    copyright = "PRAGMA ADE / ConTeXt Development Team",
    license   = "see context related readme files"
}

-- Although it sits in the lxml name space this module is pretty much hooked into
-- ConTeXt math rendering and backend code. It is one of the first applications of
-- math dictionary support. After experimenting with hooking serialization of math
-- into the rendering we decided that it made more sense to use the export
-- facilities instead. It is also a fun project that might lead so more similar
-- functionality. Of course we don't limit ourselves to English, if only because
-- our test more advanced cases are Swedish math books.
--
-- The rationale for this serialization can be found in demands for documents to be
-- accessible and math is a tricky part of that. We embed MathML in tagged PDF
-- documents and the serialization hooks into the actual text features. This is
-- needed in order to make accessibility validators (like the ones used at Lunds
-- University) happy. We let users decide how useful and reliable it is. In ConTeXt
-- you can overload and adapt bits and pieces as part of the document style. For the
-- record: we are not involved in accesibility projects, so we might get some things
-- wrong.

-- This is experimental code that will be optimized. Also, some of it can be a bit
-- more general (shared) but we do that once we're done.

-- Timestamp: yet another entertaining drum track by Gavin Harrison "Pick Up The
-- Pieces" | Zildjian 400th UK (posted 2024/2/5) - three weeks before a PT concert.

local tonumber, tostring, type = tonumber, tostring, type
local concat = table.concat
local formatters = string.formatters

local xmlall       = xml.all
local xmlfirst     = xml.first
local xmltext      = xml.text
local xmlconvert   = xml.convert
local xmlcollected = xml.collected

do

    local getname            = mathematics.dictionaries.name
    local classes            = mathematics.classes
    local getlabel           = mathematics.getverboselabel
    local functions          = mathematics.categories.functions
    local functiontype       = mathematics.functiontype

    local integral_class     <const> = classes.integral
    local implication_class  <const> = classes.implication
    local open_class         <const> = classes.open
    local close_class        <const> = classes.close
    local middle_class       <const> = classes.middle
    local prime_class        <const> = classes.prime
    local differential_class <const> = classes.differential
    local ordinary_class     <const> = classes.ordinary
    local operator_class     <const> = classes.operator

    local report = logs.reporter("mms")

    -- we don't really need to handle mfenced

    local t, n, expand, expandone, okay, language

local getverboselabel = mathematics.getverboselabel
local grouplevel      = 0

-- local function getlabel(name,language)
--     local s = getverboselabel(name,language)
--     if name == "begin group" then
--         grouplevel = grouplevel + 1
--         if grouplevel > 1 then
--             s = s .. " " .. grouplevel
--         end
--     elseif name == "end group" then
--         if grouplevel > 1 then
--             s = s .. " " .. grouplevel
--         end
--         grouplevel = grouplevel - 1
--     end
--     return s
-- end

    local function expandsymbol(c)
        local at = c.at
        if not at.mathignore then
            local result = at.mathidentity
            if not result then
                local group = tonumber(at.mathgroup)
                if group then
                    local character = tonumber(at.mathcharacter)
                    local index     = tonumber(at.mathindex)
--         print(index,character,getname(group,index),getname(group,character))
        --             local s = getname(group,index) or getname(group,character)
                    local s = getname(group,character) or getname(group,index)
                    if type(s) == "string" then
                        result = getlabel(s,language)
                    else
                        result = xmltext(c)
                    end
                else
                    result = xmltext(c)
                end
            end
            if result ~= "" then
                n = n + 1 ; t[n] = result
            end
        end
    end

    -- replace method by category and kind

    local function hasmiddle(a)
        if a then
            for i=1,#a do
                local class = tonumber(a[i].at.mathclass)
                if class == middle_class then
                    return true
                end
            end
        end
        return false
    end

    local function haslimits(at)
        local f = at.mathfunction
        if f then
            f = functions[f]
            if f then
                return f.method == "limits"
            end
        end
        return false
    end

    local function isintegral(at)
        return tonumber(at.mathclass) == integral_class
    end

    local function isoperator(at)
        return tonumber(at.mathclass) == operator_class
    end

    -- see if we can avoid passing all and i

    local function tothepower(a,all,i)
        n = n + 1 ; t[n] = getlabel("to the power of",language)
        expandone(a,all,i)
        local last = t[n]
        if last == "2" then
            n = n - 1 ; t[n] = getlabel("squared",language)
        elseif last == "3" then
            n = n - 1 ; t[n] = getlabel("cubed",language)
        end
    end

    local function checkfunction(a,i,na)
        if i + 3 <= na then
            local a1 = a[i+1]
            if a1.tg == "mo" then
                local a3 = a[i+3]
                if a3.tg == "mo" then
                    local a2 = a[i+2]
                    local t2 = a2.tg
                    if t2 == "mn" or t2 == "mi" then
                        local at1 = a1.at
                        local at3 = a3.at
                        local class1 = tonumber(at1.mathclass)
                        local class2 = tonumber(at3.mathclass)
                        if class1 and class2 and class1 == open_class and class2 == close_class then
                            at1.mathnogroup = true
                            at3.mathnogroup = true
                        end
                    end
                end
            end
        end
    end

    local partials = {
        ["âˆ‚"] = "d", -- todo: bold math
    }

    local function isdifferential(a)
        local a1 = a[1]
        local a2 = a[2]
        if a1 and a2 then
            local tg2 = a2.tg
            local ps = false
            if tg2 == "mrow" or tg2 == "msub" or tg2 == "msup" or tg2 == "msubsup" then
                local aa = xmlfirst(a2,"/*")
                if aa then
                    if aa.tg == "mi" and tonumber(aa.at.mathclass) == differential_class then
                        ps = aa
                    else
                        local aa = xmlfirst(aa,"/*")
                        if aa and aa.tg == "mi" and tonumber(aa.at.mathclass) == differential_class then
                            ps = aa
                        else
                            return false
                        end
                    end
                else
                    return false
                end
            end
            -- can be helper
            local tg1 = a1.tg
            if tg1 == "mrow" or tg1 == "msub" or tg1 == "msup" or tg1 == "msubsup" then
                local aa = xmlfirst(a1,"/*")
                if aa then
                    if aa.tg == "mi" and tonumber(aa.at.mathclass) == differential_class then
                        local p = partials[aa.dt[1]]
                        if p then
                            -- aa.at.mathidentity = p
                            -- ps.at.mathidentity = p
                            return true, true
                        else
                            return true, false
                        end
                    else
                        local aa = xmlfirst(aa,"/*")
                        if aa and aa.tg == "mi" and tonumber(aa.at.mathclass) == differential_class then
                            local p = partials[aa.dt[1]]
                            if p then
                                -- aa.at.mathidentity = p
                                -- ps.at.mathidentity = p
                                return true, true
                            else
                                return true, false
                            end
                        else
                            return false
                        end
                    end
                else
                    return false
                end
            elseif tg1 == "mi" and tonumber(a1.at.mathclass) == differential_class then
                local p = partials[a1.dt[1]]
                if partials[a1.dt[1]] then
                    -- a1.at.mathidentity = p
                    -- ps.at.mathidentity = p
                    return true, true
                else
                    return true, false
                end
            end
        end
        return false
    end

    local function expandfenced(ai,fenced)
        local at = ai.at
        local class = tonumber(at.mathclass)
        if not class then
            if at.mathnogroup then
                -- ignore
            else
                expandone(ai)
            end
        elseif class == open_class then
            if fenced or at.mathnogroup then
                -- ignore
            else
                n = n + 1; t[n] = getlabel("begin group",language)
            end
at.mathignore = "true"
expandone(ai)
        elseif class == close_class then
            if fenced or at.mathnogroup then
                -- ignore
            else
                n = n + 1; t[n] = getlabel("end group",language)
            end
at.mathignore = "true"
expandone(ai)
        elseif class == middle_class then
            if fenced then
                n = n + 1; t[n] = getlabel(fenced.tag .. ":fence",language)
at.mathignore = "true"
expandone(ai)
            else
                expandone(ai)
            end
        else
            expandone(ai)
        end
    end

    expandone = function(c,all,i,start,stop)
        if c then
            local tg = c.tg
            if tg == "mrow" then
                local at = c.at
                if at.mathunit then
                    n = n + 1; t[n] = at.mathunit
                else
                    local category = tonumber(at.mathcategory)
                    local kind     = category and functiontype(category)
                    local fenced   = kind == "fence" and functions[category]
                    local a        = xmlall(c,"/*") or { }
                    local na       = #a
                    local subfence = hasmiddle(a)
                    if na > 0 then
if at.mathfunctionstack then
    expandsymbol(c)
    at.mathnogroup = "true"
elseif at.mathfractionstack then
    at.mathnogroup = "true"
    n = n + 1; t[n] = getlabel(at.mathfractionstack,language)
end
                        -- how about na == 1
                        local mi = false
                        local nn = false
                     -- local unit = at.mathunit == "true" -- can become more generic (a tag)
                        if fenced then
                         -- nn = false
                        elseif at.mathnogroup then
                         -- nn = false
                     -- elseif unit then
                     --  -- nn = false
                        else
                            nn = n > 1
                        end
                        if fenced then
                            local s = getlabel(fenced.tag,language)
                                n = n + 1; t[n] = getlabel("optional begin",language)
                            if s == "" then
                                n = n + 1; t[n] = getlabel("fenced",language)
                            else
                                -- n = n + 1; t[n] = getlabel("begin",language)
                                n = n + 1; t[n] = s
                            end
                        elseif nn then
                            n = n + 1; t[n] = getlabel(start or "begin group",language) or "("
                     -- elseif unit then
                     --     if na == 1 then
                     --         n = n + 1; t[n] = getlabel("unit",language)
                     --         unit = false
                     --     else
                     --         n = n + 1; t[n] = getlabel("begin unit",language)
                     --     end
                        end
                        if fenced then
                            if na == 3 then
                                a[2].at.mathnogroup = true
                            elseif na == 5 then
                                if hasmiddle then
                                    a[2].at.mathnogroup = true
                                    a[3].at.mathnogroup = true
                                end
                            end
                        end
                        for i=1,na do
                            local ai = a[i]
                            local tg = ai.tg
                            if tg == "mo" then
                                expandfenced(ai,fenced)
                                mi = false
                            elseif tg == "mn" or tg == "mtext" or tg == "ms" then
                                mi = false
                                expandone(ai)
                            elseif tg == "msub" or tg == "msup" or tg == "msubsup" then
                                local first = xml.first(ai,"/*")
                                if first and first.at.mathfunction then
                                    mi = false
                                    ai.at.mathfunction = true
                                    checkfunction(a,i,na)
                                    expandone(ai,a,i)
                                else
                                    expandfenced(ai,fenced)
                                    mi = false
                                end
                            elseif ai.at.mathfunction then
                                mi = false
                                checkfunction(a,i,na)
                                expandone(ai,a,i)
                            elseif tonumber(ai.at.mathclass) ~= ordinary_class then
                                -- this might be too strict (also see derivative)
                                mi = false
                                expandone(ai,a,i)
                            else
                                if mi then
                                    local s = getlabel("times",language)
                                    if s and s ~= "" then
                                        n = n + 1; t[n] = s
                                    end
                                end
                                mi = true
                                expandone(ai,a,i)
                            end
                        end
                        if fenced then
                            local s = getlabel(fenced.tag,language)
                            n = n + 1; t[n] = getlabel("end",language)
                            if s == "" then
                                n = n + 1; t[n] = getlabel("fenced",language)
                            else
                                -- n = n + 1; t[n] = getlabel("end",language)
                                n = n + 1; t[n] = s
                            end
                        elseif nn then
                            n = n + 1; t[n] = getlabel(stop or "end group",language) or ")"
                     -- elseif unit then
                     --     n = n + 1; t[n] = getlabel("end unit",language)
                        end
                    end
                end
            elseif tg == "mo" then
                expandsymbol(c)
            elseif tg == "mn" then
                n = n + 1; t[n] = xmltext(c)
            elseif tg == "mi" then
                local at = c.at
                if at.mathunit then
                    n = n + 1; t[n] = at.mathunit
                else
                    if at.mathsymbolic then
                        n = n + 1; t[n] = getlabel("function",language)
                        expandsymbol(c) -- can be done directly
                        if all then
                            if all[i + 1] and all[i + 1].tg == "mo" then -- maybe check if class is open?
                                n = n + 1; t[n] = getlabel("functionof",language)
                            end
                        end
                    elseif at.mathfunction then
                        n = n + 1; t[n] = getlabel(c.dt[1],language)
                    else
                        expandsymbol(c)
                    end
                end
            elseif tg == "msub" then
                local a  = xmlall(c,"/*")
                local a1 = a[1]
                local at = a1.at
                expandone(a1,all,i)
                if haslimits(at) or isintegral(at) or isoperator(at) then
                    if isintegral(at) or isoperator(at) then
                        n = n + 1 ; t[n] = getlabel("integralsub",language) -- integral with lower limit
                    else
                        n = n + 1 ; t[n] = getlabel("limitsub",language) -- limit type with lower limit
                    end
                    expandone(a[2],all,i,"",getlabel("pause",language))
                    if all and #all > i then
                        n = n + 1; t[n] = getlabel("operatorof",language)
                    end
                else
                    n = n + 1 ; t[n] = getlabel("othersub",language)
                    expandone(a[2],all,i)
                end
            elseif tg == "msup" then
                local a  = xmlall(c,"/*")
                local a1 = a[1]
                local a2 = a[2]
                local at = a1.at
             -- if tonumber(a2.at.mathclass) == prime_class then
                local group = mathematics.dictionaries.groups[tonumber(a2.at.mathgroup)or -1] or "no group"
-- report("group %a",group)
                if group == "postfix operator" then
                    expandone(a2)
                    expandone(a1)
                    if all and #all > i then
                        n = n + 1 ; t[n] = getlabel("operatorof",language)
                    end
                elseif group == "prime" then
                    expandone(a1)
                    expandone(a2)
                    if all and #all > i then
                        n = n + 1 ; t[n] = getlabel("operatorof",language)
                    end
                elseif haslimits(at) or isintegral(at) or isoperator(at) then
                    expandone(a1,all,i)
                    n = n + 1 ; t[n] = getlabel("operatorsup",language)
                    expandone(a2,all,i)
                    if all and #all > i then
                        n = n + 1 ; t[n] = getlabel("operatorof",language)
                    end
                else
                    expandone(a1,all,i)
                    tothepower(a2,all,i)
                end
            elseif tg == "msubsup" then
                local a  = xmlall(c,"/*")
                local a1 = a[1]
                local a2 = a[2]
                local a3 = a[3]
                local at = a1.at
                if tonumber(a2.at.mathclass) == prime_class then
                    expandone(a2)
                    expandone(a1)
--                     expandone(a1)
--                     expandone(a2)
                    -- todo but example needed
                    if haslimits(at) or isintegral(at) or isoperator(at) then
                        n = n + 1; t[n] = getlabel("operatorsubsupfrom",language) -- from was: with lower limit
                        expandone(a3,all,i)
                    end
                    if all and #all > i then
                        n = n + 1; t[n] = getlabel("operatorof",language)
                    end
                elseif haslimits(at) or isintegral(at) or isoperator(at) then
                    expandone(a1,all,i)
                    n = n + 1; t[n] = getlabel("operatorsubsupfrom",language) -- from was: with lower limit
                    expandone(a2,all,i)
                    n = n + 1; t[n] = getlabel("operatorsubsupto",language)  -- upto was: and upper limit
                    expandone(a3,all,i)
                    if all and #all > i then
                        n = n + 1; t[n] = getlabel("operatorof",language)
                    end
                else
                    expandone(a1,all,i)
                    n = n + 1; t[n] = getlabel("othersubsup",language) -- was: indexed
                    expandone(a2,all,i)
                    tothepower(a3,all,i)
                end
            elseif tg == "mfrac" then
                local a = xmlall(c,"/*")
                local ok, partial = isdifferential(a)
                if ok then
                    if partial then
                        n = n + 1; t[n] = getlabel("the partial derivative",language)
                    else
                        n = n + 1; t[n] = getlabel("the derivative",language)
                    end
                    expandone(a[1],all,i,"","")
                    n = n + 1; t[n] = getlabel("over",language)
                    expandone(a[2],all,i,"","end derivative")
                else
                    n = n + 1; t[n] = getlabel("the fraction of",language)
                    expandone(a[1],all,i,"begin numerator","end numerator")
                    n = n + 1; t[n] = getlabel("and",language)
                    expandone(a[2],all,i,"begin denominator","end denominator")
                end
            elseif tg == "msqrt" then
                n = n + 1; t[n] = getlabel("the square root of",language)
                local a = xmlall(c,"/*")
             -- if #a > 1 then
             --     n = n + 1; t[n] = "("
             --     expand(a,t)
             --     n = n + 1; t[n] = ")"
             -- else
                    expand(a,all,i)
             -- end
            elseif tg == "mroot" then
                local a = xmlall(c,"/*")
                n = n + 1; t[n] = getlabel("the root with degree",language)
                expandone(a[2],all,i)
                n = n + 1; t[n] = getlabel("rootof",language)
                expandone(a[1],all,i)
            elseif tg == "munder" then -- needs checking
                local a        = xmlall(c,"/*")
                local category = tonumber(c.at.mathcategory)
                local category = tonumber(c.at.mathcategory)
                if functiontype(category) == "accent" then
                    local fnc = functions[category]
                    n = n + 1; t[n] = getlabel(fnc.tag,language)
                    expandone(a[1],all,i)
                else
                    expandone(a[1],all,i)
                    n = n + 1; t[n] = getlabel("under",language)
                    expandone(a[2],all,i)
                end
            elseif tg == "mover" then -- needs checking
                local a        = xmlall(c,"/*")
                local category = tonumber(c.at.mathcategory)
                if functiontype(category) == "accent" then
                    local fnc = functions[category]
                    n = n + 1; t[n] = getlabel(fnc.tag,language)
                    expandone(a[1],all,i)
                else
                    expandone(a[1],all,i)
                    n = n + 1; t[n] = getlabel("over",language)
                    expandone(a[2],all,i)
                end
            elseif tg == "munderover" then -- needs checking
                local a = xmlall(c,"/*")
                expandone(a[1],all,i)
                n = n + 1; t[n] = getlabel("under",language)
                expandone(a[2],all,i)
                n = n + 1; t[n] = getlabel("and over",language)
                expandone(a[3],all,i)
            elseif tg == "mtext" then
             -- n = n + 1; t[n] = '"'
                n = n + 1; t[n] = xmltext(c)
             -- n = n + 1; t[n] = '"'
            elseif tg == "mspace" then
                n = n + 1; t[n] = ""
            elseif tg == "ms" then
                n = n + 1; t[n] = xmltext(c)
            elseif tg == "mmultiscripts" then -- needs checking, todo prime
                local a = xmlall(c,"/*")
                local p = false
                local s = true
                for i=1,#a do
                    local ai = a[i]
                    if ai.tg == "mprescripts" then
                        p = true
                        n = n + 1; t[n] = getlabel("prescripts",language)
                    elseif p then
                        n = n + 1; t[n] = getlabel(s and "sub" or "super",language)
                        expandone(ai,all,i)
                        s = not s
                    end
                end
                s = true
                for i=1,#a do
                    local ai = a[i]
                    if ai.tg == "mprescripts" then
                        break
                    elseif i == 1 then
                       n = n + 1; t[n] = getlabel("postscripts",language)
                    end
                    n = n + 1; t[n] = getlabel(s and "sub" or "super",language)
                    expandone(ai,all,i)
                    s = not s
                end
            elseif tg == "math" then
                local a = xmlall(c,"/*")
                expand(a,all,i)
            elseif tg == "mtable" then
                local detail = c.at.detail
                if detail == "cases" then
                    n = n + 1; t[n] = getlabel("begin cases",language)
                    local nr = 0
                    for row in xmlcollected(c,"/mtr") do
                        nr = nr + 1
                        n = n + 1; t[n] = getlabel("case",language)
                        n = n + 1; t[n] = tostring(nr)
                        for cell in xmlcollected(row,"/mtd") do
                            local a = xmlall(cell,"/*")
                            expand(a)
                        end
                     -- n = n + 1; t[n] = getlabel("end case",language)
                    end
                    n = n + 1; t[n] = getlabel("end cases",language)
                else
                    n = n + 1; t[n] = getlabel("begin table",language)
                    local nr = 0
                    for row in xmlcollected(c,"/mtr") do
                        local nc = 0
                        nr = nr + 1
                     -- n = n + 1; t[n] = getlabel("row",language)
                     -- n = n + 1; t[n] = tostring(nr)
                        for cell in xmlcollected(row,"/mtd") do
                            nc = nc + 1
                         -- n = n + 1; t[n] = getlabel("column",language)
                         -- n = n + 1; t[n] = tostring(nc)
                            n = n + 1; t[n] = getlabel("cell",language)
                            n = n + 1; t[n] = tostring(nr)
                            n = n + 1; t[n] = tostring(nc)
                            local a = xmlall(cell,"/*")
                            expand(a)
                        end
                    end
                    n = n + 1; t[n] = getlabel("end table",language)
                end
            elseif not c.special then
                okay = false
                print("todo: " .. tg)
            end
        end
    end

    expand = function(all)
        if all then
            for i=1,#all do
                expandone(all[i],all,i)
            end
        end
    end

    local lpath_fence_check = formatters
        ["(msub|msup|msubsup)/mo[@mathclass='%i' or @mathclass='%i' or @mathclass='%i']"]
        (open_class,close_class,middle_class)

    local function verbose(s,l)
        local x = xmlconvert(s)
        if x.error then
            -- likely empty so nothing to print
        else
            local c = xmlall(x,"/*")
            if c then
                --
                local all = xmlall(x,"mi[not @mathfunction]")
                if all then
                    for i=1,#all do
                        local a = all[i]
                        local t = a.dt[1]
                        local f = functions[t]
                        if f then
                            local at = a.at
                            at.mathfunction = "true"
                            at.mathsymbolic = "true"
                        end
                    end
                end
                -- left  is a function
                -- right is an operator
                for c in xmlcollected(x,"mrow[@mathfunctionstack]") do
                    local cat = c.at
                    local s   = cat.mathstack
                    for cc in xmlcollected(c,"(mi|mo)[@mathstack]") do
                        local ccat = cc.at
                        if ccat.mathstack == s then
                            cat.mathfunction  = ccat.mathfunction  or cat.mathfunction
                            cat.mathcharacter = ccat.mathcharacter or cat.mathcharacter
                            cat.mathgroup     = ccat.mathgroup     or cat.mathgroup
                            if cc.tg == "mo" then
                                ccat.mathignore = "true"
                            end
                        end
                    end
                end
                local all = xmlall(x,lpath_fence_check)
                if all then
                    for i=1,#all do
                        local ai = all[i]
                        local at = ai.at
                        at.mathignore = "true"
                        ai.__p__.at.mathclass = at.mathclass
                    end
                end
                --
                n, t, okay, language = 0, { }, true, l or "en"
                expand(c)
                if okay then
-- we can have a helper for this
local m = false
for i=1,n do
    local ti = t[i]
    if ti == "" then
        if not m then
            m = i - 1
        end
    elseif m then
        m = m + 1
        t[m] = ti
    end
end
if m then
    n = m
end
if t[n] == "." then
    n = n - 1
end
                    return concat(t," ",1,n)
                end
            end
        end
    end

    local strip = true

    directives.register("structures.tags.math.strip", function(v) strip = v end)

    local function stripped(s)
        if strip then
            local x = xmlconvert(s)
            local at = { }
            for c in xml.collected(x,"*") do
                c.at = at
            end
            return tostring(x)
        else
            return s
        end
    end

    xml.mml = {
        verbose  = verbose,
        stripped = stripped,
    }

end
